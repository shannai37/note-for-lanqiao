LED流水灯

![image-20250227175534828](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250227175534828.png)

三种方法

法一 P1口赋不同值

![image-20250227175713225](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250227175713225.png)



法二 给P1赋对应值实现流水灯

```c
P1=0xFE;  //1111 1110 亮第一个灯
Delay(500);    
P1=0xFD;  //1111 1101 亮第二个灯
Delay(500);
P1=0xFB;  //1111 1011 亮第三个灯
Delay(500);
P1=0XF7;  //1111 0111 亮第四个灯
Delay(500);
```



法三 内置函数库

 ____crol____(位移的变量，位移的位数)    循环左移

 ____cror____(位移的变量，位移的位数)    循环右移

```c
/*头函数添加部分*/
#include <intrins.h>
```

![image-20250227181455522](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250227181455522.png)

#### 流的越来越快？

![image-20250227181647824](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250227181647824.png)

流的越来越慢就加time=time+100  一样的



### 按键

引脚接到P3_4到P3_7 ,读到0就是按下按键，没读到就是熄灭

#### 按键控制LED亮灭状态

```c
/*变量声明区域*/
unsigned char Key_Val,Key_Down,Key_Up,Key_Old;

/*按键读取函数*/
unsigned char Key_Read()
{
	unsigned char temp = 0;
	if(P3_4==0) temp = 1;
	if(P3_5==0) temp = 2;
	if(P3_6==0) temp = 3;
	if(P3_7==0) temp = 4;
	
	return temp;
}
void main()
{
	while(1)
	{
		Key_Val = Key_Read();//读取键码值
		Key_Down = Key_Val & (Key_Val ^ Key_Old); //检测下降沿
		Key_Up = ~Key_Val &  (Key_Val ^ Key_Old);  //检测上升沿
		Key_Old = Key_Val; //扫描辅助变量
	
		if(Key_Down==1)
			P1_0 = 0;
		if(Key_Up==2)
			P1_0 = 1;
		
		if(Key_Old == 3) //按键3一直按下D2就亮，松手就灭
			P1_1 = 0;
		else
			P1_1 = 1;
	}
}
```

流水灯暂停加启动？

就是上节流水灯的三句代码加启动和暂停

```c
#include <REGX52.H>
#include <intrins.h>

/*变量声明区域*/
unsigned char ucLed = 0xfe;
unsigned char Key_Val,Key_Down,Key_Up,Key_Old;
bit System_Flag = 0;

void Delay(unsigned char xms)		//@12.000MHz
{
	unsigned char i, j;
	while(xms--)
	{
		i = 2;
		j = 239;
		do
		{
			while (--j);
		} while (--i);
	}
}

unsigned char Key_Read()
{
	unsigned char temp = 0;
	if(P3_4==0) temp = 1;
	if(P3_5==0) temp = 2;
	if(P3_6==0) temp = 3;
	if(P3_7==0) temp = 4;
	

	return temp;

}



void main()
{
	while(1)
	{
		Key_Val = Key_Read();
		Key_Down = Key_Val & (Key_Val ^ Key_Old);
		Key_Up = ~Key_Val &(Key_Val ^ Key_Old);
		Key_Old = Key_Val;
		if(System_Flag==1)
		{
			ucLed = _crol_(ucLed,1);
			P1 = ucLed;
			Delay(500);
		}
//		//按下K1启动，按下K2暂停 
//		if(Key_Down == 1) 
//			System_Flag=1;
//		if(Key_Down == 2)
//			System_Flag=0;
		switch(Key_Down)
		{
			case 1:
				System_Flag = 1;
				break;
			case 2:
				System_Flag = 0;
				break;
		}
	}
}
```



### 矩阵键盘

P3_0 到 P3_3  先选择行，再扫描列（即选中第一行后，去选择S6或S7或S8或S9）

![image-20250228172124007](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250228172124007.png)

如图，简单的就这么写，先选择行，再扫描列

![image-20250301143305112](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250301143305112.png)



#### 例题：彩灯控制系统

![image-20250301152500227](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250301152500227.png)

模式1、2很简单  模式3、4呢

其实思路也是很简单的，首先可以直接给P1赋值，像这样

```c
if(System_Flag==1)
{
    switch(Led_Mode)
    {
        case 3:
            P1=0x7E;//0111 1110
            Delay(500);
            P1=0xBD;//1011 1101
            Delay(500);
            P1=0xDB;//1101 1011
            Delay(500);
            P1=0xE7;//1110 0111
            Delay(500);
         break;
     }
}
```

但是同样的，我们也有灵活一点的做法（其实跟上面这种差不多）

```c
//首先定义数组
unsigned char Led_S3[4] = {0x7E,0xBD,0xDB,0xE7};
//然后定义数组索引值
unsigned char Led_S3_Index = 0;

//回到模式3
if(System_Flag==1)
{
    switch(Led_Mode)
    {
        case 3:
    		P1 = Led_S3[Led_S3_Index];
    		Delay(500);
    		Led_S3_Index++;
    		if(Led_S3_Index==4) Led_S3_Index=0;
    	break;
}
```



整套逻辑供参考

```c
/*头文件声明*/
#include <REGX52.H>
#include <intrins.h>
/*变量声明*/
unsigned char Key_Val,Key_Down,Key_Old;
unsigned char Led_Data = 0xFE;//1111 1110第一个灯D1开始亮
unsigned char Led_S3[4] = {0x7E,0xBD,0xDB,0xE7};//18亮 27亮 36亮 45亮
unsigned char Led_S3_Index = 0;
unsigned char Led_Mode = 0;
bit Led_Flag = 1;
/*键盘检测函数*/
unsigned char Key_Read()
{
    unsigned char temp = 0;
    if(P3_4 ==0) temp = 1;
    if(P3_5 ==0) temp = 2;
    if(P3_6 ==0) temp = 3;
    if(P3_7 ==0) temp = 4;
    return temp;
}
/*延时函数*/
void Delay(unsigned char xms)
{}
/*主函数*/
void main()
{
    	while(1)
        {
            Key_Val = Key_Read();
            Key_Down = Key_Val & (Key_Val ^ Key_Old);
            Key_Up = Key_Val & (Key_Val ^ Key_Old);
            Key_Old = Key_Val;
            switch(Key_Down)
                case 1:	//启动按键
            		System_Flag = 1;
            	break;	
            	case 2:	//暂停按键
            		System_Flag = 0;
            	break;
                case 3://模式+
                    Led_Mode++;
                    if(Led_Mode == 4) Led_Mode = 0;
                break;
            	case 4://模式-
            		Led_Mode--;
            		if(Led_Mode == 255) Led_Mode = 3;
         			//unsigned char 范围 0-255  
            		//0往下减就是255
            	break;
        }
    if(Led_Flag = 1)
    {
        switch(Led_Mode)
            case 0: //从LED1到LED8
        		P1 = Led_Data;
        		Delay(500);
        		Led_Data = _crol_(Led_Data,1);
        		//Led_Data数据左移一位
        	break;
    		case 1: //从LED8到LED1
        		P1 = Led_Data;
        		Delay(500);
        		Led_Data = _cror_(Led_Data,1);
        		//Led_Data右移一位
        	break;
        	case 2: //LED1+LED8 LED2+LED7 ...
        		P1 = Led_S3[Led_S3_Index];
                Delay(500);
                Led_S3_Index++;
                if(Led_S3_Index==4) Led_S3_Index=0;
        	break;
    		case 3: //LED4+LED5 LED3+LED6 ...
        		P1 = Led_S3[Led_S3_Index];
                Delay(500);
                Led_S3_Index--;
                if(Led_S4_Index==255) Led_S3_Index=3;
    		break;
    }
}
```



### SEG原理图 段选 位选

数码管分成段选和位选   段选指的是单个数码管中的八个LED灯怎么去亮

 位选指的是总共有6个数码管，哪个数码管怎么去亮

![image-20250304173825477](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250304173825477.png)

这块单片机是给0灭 给1亮

首先是段选  段码怎么看呢？给1是选中 比如要显示1，那就能得到如图的LED灯情况

![image-20250304174756915](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250304174756915.png)

然后去得到01的二进制 先看小数点 然后是中间 然后是左上、左下、中下、右下、右上、中上  得到00000110（二进制），再转换成16进制数0x06，0x06就是我们“数字1”的段码

位选  位码怎么看呢？位分布在后面6个口 给0是选中  如果选中第一个数码管，二进制就是 1111 1110 ，十六进制就是0xFE，即0xFE选中第一个数码管 那选中第二个就是1111 1101，0xFD 

#### 静态数码管

段选 P2_6   位选P2_7  比赛段码和位码都会给

段码指你在该数码管要显示什么内容   位码指你选中数码管的位置

数码管函数第一步消隐  

```c
P0 = 0x00； //数码管熄灭

P2_6 = 1;	//开门（锁存器高电平，数据由输入端P0传入输出端数码管）

P2_6 = 0;	//关门（锁存器低电平，数据被锁定，不再由输入端变化）
```

随后再选择位  再选择段

```c
/*比赛给的位码和段码*/
unsigned char Seg_Dula[] = {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x00}; //段码
unsigned char Seg_Wela[] = {0xfe,0xfd,0xfb,0xf7,0xef,0xdf}; //位码
/*数码管显示函数*/
void Seg_Disp(unsigned char wela,dula)
{
    /*消隐*/
    P0 = 0x00;
    P2_6 = 1;
    P2_6 = 0;
    
    /*选择位*/
    P0 = Seg_Wela[wela];
    P2_7 = 1;
    P2_7 = 0;
    
    /*再选择段*/
    P0 = Seg_Dula[dula];
    P2_6 = 1;
    P2_6 = 0;
}
/*主函数中*/
void main()
{
    while(1)
	{
		Key_Val = Key_Read();
		Key_Down = Key_Val & (Key_Val ^ Key_Old);
		Key_Up = ~Key_Val &(Key_Val ^ Key_Old);
		Key_Old = Key_Val;
		if(System_Flag==1)
		{
			ucLed = _crol_(ucLed,1);
			P1 = ucLed;
			Delay(Time);
		}
//		//按下K1启动，按下K2暂停 
//		if(Key_Down == 1) 
//			System_Flag=1;
//		if(Key_Down == 2)
//			System_Flag=0;
		switch(Key_Down)
		{
			case 1:
				System_Flag = 1;
				break;
			case 2:
				System_Flag = 0;
				break;
			case 3: //减速
				Time += 100;
				break;
			case 4:	//加速
				Time -= 100;
				break;
		}
		
		Seg_Disp(0,0); 
//		Seg_Disp(1,1);	
		//只能亮一个数码管，若直接重复调用，会导致后面的效果覆盖前面的效果,即第二个数码管亮1 要用到动态数码管解决
	}
}
```

#### 动态数码管

![image-20250305150803868](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250305150803868.png)

```C
1./*定时器初始化函数*/
void Timer0Init(void)		//1毫秒@12.000MHz
{
	
	TMOD &= 0xF0;		//设置定时器模式
	TMOD |= 0x01;		//设置定时器模式
	TL0 = 0x18;		//设置定时初值
	TH0 = 0xFC;		//设置定时初值
	TF0 = 0;		//清除TF0标志
	TR0 = 1;		//定时器0开始计时
    ET0 = 1;		//允许定时器0中断
    EA = 1;			//总中断开关
}
2./*主函数中调用*/
void main()
{
    Timer0Init();
}
```



上述为定时器初始化函数，删去AUXR那句后，加上ET0 =1（允许定时器中断）和EA = 1（总中断开关）两句即可

```c
/*变量声明区域*/
unsigned char Seg_Pos = 0;	//位选，哪个数码管亮
unsigned char Seg_Buf[] = {1,2,3,4,5,6};	//第几个数码管中要亮哪个具体数字	
/*定时器0中断服务函数*/
void Timer0Server() interrupt 1
{
	/*1.复制初始化函数中初始值*/
	TL0 = 0x18;		//设置定时初值
	TH0 = 0xFC;		//设置定时初值

	if(Seg_Pos++ == 6)	Seg_Pos = 0;
	Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos]);
	//Seg_Buf[Seg_Pos]每个数码管亮哪个数字，比如Seg_Pos = 0,那就是第Seg_Buf[0],第一个数码管亮1

}		
```

我没成功，按理来说要在数码管显示123456的

![image-20250310150920161](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250310150920161.png)



## 校赛大模版（一代）

1.头文件

2.变量声明

3.Key_Proc()

4.Seg_Proc()

5.Led_Proc()

6.Time0Init()

7.Server 中断服务函数

8.main

见PDF，这里只挑部分来说

时间片轮询加前后端分离

#### 1.1 为什么要手动设置Key_Slow_Down、Seg_Slow_Down为1？

![image-20250310155651986](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250310155651986.png)



当Key_Slow_Down、Seg_Slow_Down为1-9时，直接return（跳过），等到为0时就把它赋值为1

这里的标志Key_Slow_Down、Seg_Slow_Down标记为1相当于重置初始值，下一次中断计时又从1-9，一共9ms，然后当9-10的时候，10会变成0（后面代码写的），这里是1ms，一共10ms的延时循环往复。

while中执行的速度是很快的 而定时器中断是1ms一次 即进入中断从0变到1还需要1ms 在这1ms中会执行很多次按键检测程序，就相当于0-1这个过程中没有减速 所以需要手动设置为1 避免这种情况发生

不用delay是因为程序会卡



### 2、模块化编程

建立两个文件夹 User-用户层(main) Driver -底层（固定）

建立工程模版 -编写底层函数 Key（按键模块）、Seg（数码管模块）

.c编写底层函数 .h声明底层函数

##### 2.1 Key

Key.c的步骤：

1.引入key.h的头文件

2.写Key_Read（）

```C
#include "Key.h"
unsigned char Key_Read()
{
    unsigned char temp  =  0;
    if(P3_4 == 0) temp = 1;
    if(P3_5 == 0) temp = 2;
    if(P3_6 == 0) temp = 3;
    if(P3_7 == 0) temp = 4;
    return temp;
}
```

```c
#include "Key.h"

unsigned char Key_Read()
{
	unsigned char temp = 0;
	P3_0 = 0; P3_1 = 1; P3_2 = 1; P3_3 = 1;
	if(P3_4 == 0) temp = 1;
	if(P3_5 == 0) temp = 2;
	if(P3_6 == 0) temp = 3;
	if(P3_7 == 0) temp = 4;
	P3_0 = 1; P3_1 = 0; P3_2 = 1; P3_3 = 1;
	if(P3_4 == 0) temp = 5;
	if(P3_5 == 0) temp = 6;
	if(P3_6 == 0) temp = 7;
	if(P3_7 == 0) temp = 8;
	P3_0 = 1; P3_1 = 1; P3_2 = 0; P3_3 = 1;
	if(P3_4 == 0) temp = 9;
	if(P3_5 == 0) temp = 10;
	if(P3_6 == 0) temp = 11;
	if(P3_7 == 0) temp = 12;
	P3_0 = 1; P3_1 = 1; P3_2 = 1; P3_3 = 0;
	if(P3_4 == 0) temp = 13;
	if(P3_5 == 0) temp = 14;
	if(P3_6 == 0) temp = 15;
	if(P3_7 == 0) temp = 16;
	
	return temp;
}
```

Key.h步骤:

1.声明Key_Read()函数

2.引入引脚的头文件 #include <REGX52.h>

##### 2.2 Seg

Seg.c步骤：

1.引用Seg.h的头文件

2.段码位码

3.写 Seg_Disp()

```C
#include "Seg.h"

unsigned char Seg_Dula[] = {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x00};//数码管段码储存数组
unsigned char Seg_Wela[] = {0xfe,0xfd,0xfb,0xf7,0xef,0xdf};//数码管位码储存数组

void Seg_Disp(unsigned char wela,dula)
{
    P0 = 0x00; //消影
    P2_6 = 1;
    P2_6 = 0;
    
    P0 = Seg_Wela[wela];
    P2_7 = 1;
    P2_7 = 0;
    
    P0 = Seg_Dula[dula];
    p2_6 = 1;
    P2_6 = 0;
}
```

Seg.h步骤:

1.声明Seg_Disp()函数

2.引入引脚的头文件 #include <REGX52.h>



##### 2.3 Main

1.头文件

2.变量声明

3.Key_Proc()

4.Seg_Proc()

5.Led_Proc()

6.Time0Init()

7.Server 中断服务函数

8.main

#### 2.4 按键减速和seg内减速（延时消抖）的作用

一条语句1微妙，假如main函数一个执行周期要20ms，但是我有一个芯片，它处理数据的周期是750ms（典型的ds18b20）

如果不加减速就会造成我这次的数据还在处理，下一次的数据就进来了，所以我们**就要通过减速，让它来减缓我们每次对信息处理的一个刷新时间**。这就是我们Seg减速的作用

我们按键减速也是同理，按键的减速就是让它检测的不那么灵敏



#### 2.5 大模板整体

```c
/*头文件声明区*/
#include <REGX52.H>
#include "Key.h" //笔记中Key部分写了Key.c
#include "Seg.h" //笔记中Seg部分写了Seg.c
/*变量声明区*/
unsigned char Key_Slow_Down; //按键减速专用变量 10ms
unsigned int Seg_Slow_Down;	//数码管减速专用变量 500ms 
unsigned char Key_Val,Key_Down,Key_Old;//按键扫描专用变量
unsigned char Seg_Pos; //数码管扫描变量
unsigned char Seg_Buf[6] = {1,2,3,4,5,6};//数码管显示数据存放数组

/*按键处理函数*/
void Key_Proc()
{
	if(Key_Slow_Down) return;
    Key_Slow_Down = 1; //按键减速程序
  
    Key_Val = Key_Read(); //读取按下的键码值
    Key_Down = Key_Val & (Key_Val ^ Key_Old);//捕捉下降沿
    Key_Old = Key_Val; //辅助扫描
    
    switch(Key_Down)
    {
            
    }
}
/*信息处理函数*/
void Seg_Proc()
{
    if(Seg_Slow_Down) return;
    Seg_Slow_Down = 1; //数码管减速程序
}

/*其他显示函数*/
void Led_Proc()
{
    
}

/*定时器0初始化函数*/  
/* 1.STC-ISP生成 2.删除AUXR 3.加ET0和EA*/ 
void Timer0Init(void)		//1毫秒@12.000MHz
{
	TMOD &= 0xF0;		//设置定时器模式
	TMOD |= 0x01;		//设置定时器模式
	TL0 = 0x18;		//设置定时初值
	TH0 = 0xFC;		//设置定时初值
	TF0 = 0;		//清除TF0标志
	TR0 = 1;		//定时器0开始计时
	
    ET0 = 1;
    EA = 1;
}
/*定时器0中断服务函数*/
/*1.复制定时器中初值TL0和TH0 2.配置按键和数码管减速专用变量
3.数码管显示配置和函数*/
void Timer0Server() interrupt 1
{
    TL0 = 0x18;		//设置定时初值
	TH0 = 0xFC;		//设置定时初值
    if(++Key_Slow_Down == 10)Key_Slow_Down = 0;
    if(++Seg_Slow_Down == 500)Seg_Slow_Down = 0;
	if(++Seg_Pos == 6) Seg_Pos = 0;
    Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos]);
}
/*main*/
/*1.初始化函数引用 2.While里写 按键、数码管、LED处理函数*/
void main()
{
    Timer0Init();
    while(1)
    {
        Key_Proc();
        Seg_Proc();
        Led_Proc();
    }
}
```

**md一定要记得将头文件路径加进去，因为这个老子一条报错测试了一个小时**

main.c(62): error C267: 'Seg_Disp': requires ANSI-style prototype

![image-20250318171338916](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250318171338916.png)

### 蜂鸣器

P2_3  0是响 1是灭

![image-20250318160425067](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250318160425067.png)

仿真图中看这个小点 蓝色就是响了 红色就是没响



### 做人家校赛模拟题部分：倒计时

详情请见 第二届 创意智造....模拟题.pdf 看代码请喝题目结合观看

4.3显示功能->有多种显示界面->写一个显示界面变量

```c
unsigned char Seg_Mode; //数码管显示界面，不赋值默认值是0 0-显示 1-设置
```





显示界面模式标识是1->去信息处理函数Seg_Proc（）里面去写->

观察可知 模式标识 = Seg_Mode+1

熄灭的话让Seg_Buf[1]~Seg_Buf[3] = 10 就行，10是熄灭

（unsigned char Seg_Dula[] = {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,**0x00**};//数码管段码储存数组  =10熄灭是这个原因，因为0x00是熄灭）

倒计时设置个计时变量Time_Count , 由于我们定时器是1毫秒的，所以在中断中设置1000ms的标志位Timer_1000ms,满1000ms的话Time_Count-1

![image-20250319141835632](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250319141835632.png)

这里仅写需求部分

```C
/*变量声明*/
unsigned int Timer_1000ms; //1000毫秒标志位
unsigned char Time_Count = 30; //系统计时变量
/*信息处理函数*/
void Seg_Proc()
{
    Seg_Buf[0] =  Seg_Mode+1 // 模式标识
    if(Seg_Mode == 0) //显示界面
    {
        Seg_Buf[4] = Time_Count/10 % 10; //如果Time_Count<100的情况下，写Time_Count/10就行	
		Seg_Buf[5] = Time_Count % 10;
    }
}

/*中断服务函数*/
void Timer0Server() interrupt 1
{
    if(++Timer_1000ms == 1000)
	{
		Timer_1000ms = 0;
		Time_Count--;
	}
}
```







接着处理按键



![image-20250319142612999](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250319142612999.png)

![image-20250319143802432](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250319143802432.png)

第一个按键S1简单，可以先搞,但要注意  S1只在显示界面有效

```C
/*变量声明*/
bit System_Flag; //系统标志位 0-暂停  1—开始
/*Key_Proc*/
void Key_Proc()
{
    
    switch(Key_Down)
    {
        case 1:
            if(Seg_Mode == 0)
                System_Flag = 1;
        break;
    }
}
/*中断服务*/
void Timer0Server() interrupt 1
{
    if(System_Flag == 1)
	{
		if(++Timer_1000ms == 1000)
		{
			Timer_1000ms = 0;
			Time_Count--;
		}
	}
}
```

S2复位我们要考虑多一点，因为设置界面也有参数，且其参数为15-30-60，那就不能直接等于30了，所以我们先写S3切换

```C
/*Key_Proc*/
void Key_Proc()
{
	switch(Key_Down)
	{
		
		case 3://切换
			Seg_Mode = ！Seg_Mode;
		break;
	}
	
}
```

为啥我是0 和1变换？

**因为取反要用感叹号，不用~，~是按位取反**



做S4设置按键 不建议直接什么乘2除2，用数组好一点，也是考的初衷

![image-20250319152141450](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250319152141450.png)

![image-20250319143802432](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250319143802432.png)

```C
/*变量声明*/
unsigned char Seg_Dat[3] = {15,30,60}; //S4设置按钮的储存数组
unsigned char Seg_Dat_Index = 1; //初始设置参数为30s
/*Key_Proc*/
void Key_Proc()
{
    case 4://设置
			if(Seg_Mode == 1)
			{
				if(++Seg_Dat_Index == 3)
					Seg_Dat_Index = 0;
			}
		break;
}
/*Seg_Proc*/
void Seg_Proc()
{
	
	else //系统处于设置界面
	{
		Seg_Buf[4] = Seg_Dat[Seg_Dat_Index] /10 % 10; 
		Seg_Buf[5] = Seg_Dat[Seg_Dat_Index] % 10;
	}
}

```

然后为了使设置界面的的倒计时能应用到显示界面，还需要在写切换按钮时纪录下设置界面的倒计时

```C
/*Key_Proc*/
void Key_Proc()
{
		case 3://切换
    		if(Seg_Mode == 1)
				Time_Count = Seg_Dat[Seg_Dat_Index]; 
			Seg_Mode = !Seg_Mode; //取反用感叹号，不用~，~是按位取反
		break;

}
```

随后进行复位按钮 注意：1.只在显示界面有效 2.复位是复位成设置的初始值，而不是固定30

```C
/*Key_Proc*/
void Key_Proc()
{
	case 2://复位
			if(Seg_Mode == 0)
				Time_Count = Seg_Dat[Seg_Dat_Index]; 
}
```

为防止倒计时结束后又从55开始计时（因为Time_Count是char类型，范围是0~255，所以Time_Count减到0后再减一是255，后两位是55，所以会从55开始计时），我加了一句

```C
/*中断服务函数*/
void Timer0Server() interrupt 1
{
	
    if(System_Flag == 1)
    {
        if(++Timer_1000ms == 1000)
        {
            Timer_1000ms = 0;
            if(Time_Count)
                Time_Count--;
        }
    }

}
```

（加if(Time_Count == 255也行)）

最后一步就是设置界面的倒计时以1秒为周期闪烁，那其实就是以500ms周期取反

想要闪烁，写一个变量Seg_Flag，每500ms在0和1之间变换，1的时候亮,0的时候熄灭就行

```C
unsigned int Timer_500ms;	//500ms标志位
bit Seg_Flag;	//数码管标志位
/*Seg_Proc*/
void Seg_Proc()
{
	else //系统处于设置界面
	{
		if(Seg_Flag == 1)
		{
			Seg_Buf[4] = Seg_Dat[Seg_Dat_Index] /10 % 10; 
			Seg_Buf[5] = Seg_Dat[Seg_Dat_Index] % 10;
		}
		else
		{
			Seg_Buf[4] = 10;
			Seg_Buf[5] = 10;
		}
	}
}
/*中断服务函数*/
void Timer0Server() interrupt 1
{
	
	if(++Timer_500ms == 500)
	{
		Timer_500ms = 0;
		Seg_Flag = !Seg_Flag;
	}
		
}
```

这里是70分的部分

剩下三十分是主观选择题 4-5道c语言基础 剩下5-6道可以去手册里翻（考试时会给手册）

比如考间接寻址，就**先复制文档中的间接寻址，然后crtl+F搜索**（一定要复制文档中的，因为可能编码不一样，打上去的字识别不出来，具体情况具体讨论，我也不知道比赛是什么情况）



### 模拟题：时钟

![image-20250326143528016](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250326143528016.png)

补充知识：

异或^ : 变量 ^1 是取反   变量 ^0 是不变

思路：

首先看到三种模式 先创建变量 Seg_Mod 来表示不同的模式

时钟显示界面 0 	时钟设置界面 1 闹钟设置界面 2 

创建一个数组Seg_Time[3] = {23,59,55} 专门表示 时钟显示界面，同样满足了上电初始化时间 

然后将其显示在数码管上

```c
case 0:
			for( i = 0; i < 3;i++)
			{
				Seg_Buf[i*2] = Seg_Time[i] / 10 % 10;     
				Seg_Buf[i*2+1] = Seg_Time[i] % 10;         
			}
		break;
		
```

时钟显示界面的时钟肯定是要跑的，所以创建变量Timer_1000ms 在中断函数中创建关于时分秒的逻辑

```c
if(++Timer_1000ms == 1000)
	{
		Timer_1000ms = 0;
		Seg_Time[2]++;
		if(Seg_Time[2] == 60)
		{
			Seg_Time[2] = 0;
			Seg_Time[1]++;
			if(Seg_Time[1] == 60)
			{
				Seg_Time[1] = 0;
				Seg_Time[0]++;
				if(Seg_Time[0] == 24)
				{
					Seg_Time[0] = 0;
				}
			}
			
		}
	}
```

同理，创建一个数组Seg_Set[3] 专门表示时钟设置界面 ，由于正常逻辑是到时钟设置界面的时候，此时时间跟时钟显示界面相同，所以case 1的时候应该 	

```c
  Seg_Set[0] = Seg_Time[0];
  Seg_Set[1] = Seg_Time[1];
  Seg_Set[2] = Seg_Time[2];
  Seg_Mod = 1;
```

数码管显示部分有小数点，所以我们要改一下底层的函数了

![image-20250327103038752](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250327103038752.png)

小数点是数码管最后一位，即0x80  我们在main函数中设置需要放小数点位数的数组Seg_Point[6] ={0,1,0,1,0,1} ，然后改底层函数就好了

```c
void Seg_Disp(unsigned char wela,dula,point)
{
	P0 = 0x00;
	P2_6 = 1;
	P2_6 = 0;
	
	P0 = Seg_Wela[wela];
	P2_7 = 1;
	P2_7 = 0;
	
	if(point == 1)		
	P0 = Seg_Dula[dula] | 0x80;
	else
	P0 = Seg_Dula[dula];	
	P2_6 = 1;
	P2_6 = 0;
	
}

/*main函数*/
unsigned char Seg_Point[6] ={0,1,0,1,0,1};
/*中断函数内*/
void Timer0Server() interrupt 1
{
    	Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos],Seg_Point[Seg_Pos]);
}
```

题目说“选中的数码管以 0.5 秒/次的周期闪烁” 加上按钮S3功能是设置切换

按钮的切换功能我们创建一个变量Seg_Set_Index（时钟闪烁 0  分钟闪烁 1  秒钟闪烁 2），用switch结构就能完成  要以0.5s/次的周期闪烁，闪烁的本质就是一半的时间熄灭，一半的时间亮，所以我们要创建变量Timer_500ms用于闪烁（所以我觉得应该是250ms，但是250ms仿真直接不亮了） ，创建变量Flag用于亮暗切换（直接异或1（即取反），将其中一个状态设置为亮即可）



![image-20250326145425171](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250326145425171.png)

```c
case 3:
    if(++Timer_500ms == 500)
        {
            Timer_500ms = 0;
            Flag ^= 1;
        }
break;
```

上面是中断部分，按钮的切换功能部分如下，我们用覆盖的方法，然后用switch结构让各个部分闪起来就行

```c
if(++Seg_Set_Index == 3)
				{
					Seg_Set_Index = 0;
				}
```



```c
	case 1://使用覆盖的方法，使S3能实现切换闪烁
			Seg_Buf[0] = Seg_Set[0] /10 %10;
			Seg_Buf[1] = Seg_Set[0] %10;
			Seg_Buf[2] = Seg_Set[1] /10 %10;
			Seg_Buf[3] = Seg_Set[1] %10;
			Seg_Buf[4] = Seg_Set[2] /10 %10;
			Seg_Buf[5] = Seg_Set[2] %10;
			switch(Seg_Set_Index)
			{
				case 0:
					Seg_Buf[0] = Flag ? Seg_Set[0] /10 %10 : 10;
					Seg_Buf[1] =Flag ? Seg_Set[0] %10 : 10;
				break;
				
				case 1:
					Seg_Buf[2] = Flag ? Seg_Set[1] /10 %10 : 10;
					Seg_Buf[3] =Flag ? Seg_Set[1] %10 : 10;	
				break;
				case 2:
					Seg_Buf[4] = Flag ? Seg_Set[2] /10 %10 : 10;
					Seg_Buf[5] =Flag ? Seg_Set[2] %10 : 10;
				break;
			}
		break;
```

ok,S1和S3的功能我们已经完成，随后进行S5、S6部分的编写

![image-20250326152118396](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250326152118396.png)

看到后得想到，肯定是在时钟设置界面（Seg_Mod = 1）下才进行参数变更，同时还得考虑时分秒的上边界和下边界问题

切换变量我们已经设置了，是Seg_Set_Index（时钟闪烁 0  分钟闪烁 1  秒钟闪烁 2），所以让Seg_Set[Seg_Set_Index]++就行  

然后只有两种上边界 24 和 60，不是24 就是 60，而且24对应的是Seg_Set_Index = 0,所以考虑清楚后我们用三目运算符来写

if(Seg_Set[Seg_Set_Index] == (Seg_Set_Index ==0 ? 24 : 60))

达到上边界之后 Seg_Set[Seg_Set_Index] = 0

整合：

```c
switch (Key_Down)
{
    case 5:
				Seg_Set[Seg_Set_Index]++;
			if(Seg_Set[Seg_Set_Index] == (Seg_Set_Index == 0 ? 24 :60))
				Seg_Set[Seg_Set_Index] = 0;
    break;
}
```

下边界同理，只不过要注意一点，我们unsigned char类型的 0减1后是255

```c
Seg_Set[Seg_Set_Index]--;
			if(Seg_Set[Seg_Set_Index] == 255)//char类型0-1=255 
				Seg_Set[Seg_Set_Index] = (Seg_Set_Index == 0 ? 23 :59);
```

写S7 S8

![image-20250326154657976](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250326154657976.png)

一样的，肯定是在时钟设置界面（Seg_Mod = 1）才需要确认和退出

如果是确认按键，需要把修改的参数值保存，即

```c
	Seg_Time[0] = Seg_Set[0];
	Seg_Time[1] = Seg_Set[1];
	Seg_Time[2] = Seg_Set[2];
```

随后返回显示界面就行

```c
Seg_Mod = 0;
```

退出按键直接返回显示界面

```c
Seg_Mod = 0;
```

![image-20250326155246091](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250326155246091.png)

闹钟设置，想一想 ，一个是显示闹钟被设置成什么样了，一个是调试闹钟，所以需要两个数组，Alarm[3] = {0,0,0}   Alarm_Set[3] 

数码管以0.5/次闪烁，直接用我们之前设置好的Timer_500ms

按下S2按钮进入到闹钟设置界面后，将Alarm[3] = {0,0,0}赋值给

 Alarm_Set[3] ，逻辑跟时钟显示和设置界面的是一样的，要将显示界面的值赋值给设置界面的。

```c
	Alarm_Set[0] = Alarm[0];
	Alarm_Set[1] = Alarm[1];
	Alarm_Set[2] = Alarm[2];
	Seg_Mod = 2;
```

闪烁的话我们改改S3就行，也就是现在时钟设置和闹钟设置界面都可以用

```c
case 3:
			if(Seg_Mod == 1 | Seg_Mod == 2)
			{
				if(++Seg_Set_Index == 3)
				{
					Seg_Set_Index = 0;
				}
			}
		break;
```

```c
case 2:
			Seg_Buf[0] = Alarm_Set[0] /10 %10;
			Seg_Buf[1] = Alarm_Set[0] %10;
			Seg_Buf[2] = Alarm_Set[1] /10 %10;
			Seg_Buf[3] = Alarm_Set[1] %10;
			Seg_Buf[4] = Alarm_Set[2] /10 %10;
			Seg_Buf[5] = Alarm_Set[2] %10;
			switch(Seg_Set_Index)
			{
				case 0:
					Seg_Buf[0] = Flag ? Alarm_Set[0] /10 %10 : 10;
					Seg_Buf[1] =Flag ? Alarm_Set[0] %10 : 10;
				break;
				
				case 1:
					Seg_Buf[2] = Flag ? Alarm_Set[1] /10 %10 : 10;
					Seg_Buf[3] =Flag ? Alarm_Set[1] %10 : 10;	
				break;
				case 2:
					Seg_Buf[4] = Flag ? Alarm_Set[2] /10 %10 : 10;
					Seg_Buf[5] =Flag ? Alarm_Set[2] %10 : 10;
				break;
			}
		break;
```

那S5 和 S6也要改，把数组换一下就行

```c
case 5:
			if(Seg_Mod == 1)
			{
				Seg_Set[Seg_Set_Index]++;
			if(Seg_Set[Seg_Set_Index] == (Seg_Set_Index == 0 ? 24 :60))
				Seg_Set[Seg_Set_Index] = 0;
			}
			if(Seg_Mod == 2)
			{
				Alarm_Set[Seg_Set_Index]++;
			if(Alarm_Set[Seg_Set_Index] == (Seg_Set_Index == 0 ? 24 :60))
				Alarm_Set[Seg_Set_Index] = 0;
			}
		break;
		
		case 6:
			if(Seg_Mod == 1)
			{
				Seg_Set[Seg_Set_Index]--;
			if(Seg_Set[Seg_Set_Index] == 255)//char类型0-1=255 
				Seg_Set[Seg_Set_Index] = (Seg_Set_Index == 0 ? 23 :59);
			}
			if(Seg_Mod == 2)
			{
				Alarm_Set[Seg_Set_Index]--;
			if(Alarm_Set[Seg_Set_Index] == 255)//char类型0-1=255 
				Alarm_Set[Seg_Set_Index] = (Seg_Set_Index == 0 ? 23 :59);
			}
		break;
		
```

S7也要改

```c
	case 7:
			if(Seg_Mod == 1)
			{
				Seg_Time[0] = Seg_Set[0];
				Seg_Time[1] = Seg_Set[1];
				Seg_Time[2] = Seg_Set[2];
			}
			if(Seg_Mod == 2)
			{
				Alarm[0] = Alarm_Set[0];
				Alarm[1] = Alarm_Set[1];
				Alarm[2] = Alarm_Set[2];
			}
			Seg_Mod = 0;
				
		break;
```

![image-20250326163118497](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250326163118497.png)

![image-20250326163131193](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250326163131193.png)

接着写S4，其实很简单，一眼看出来，我们设置个变量Alarm_Flag = 1，默认是开启的就好了

```c
case 4:
			Alarm_Flag ^= 1; 
			
		break;
```

看蜂鸣器和Led灯，都是到达闹钟设置的时间，然后干嘛干嘛，说明能写到一起，然后分开来看

蜂鸣器开启关闭，那就是P2_3如何  =1是开，=0是关

看Led灯，以500ms闪烁，可以写变量在外面闪烁，跟我们前面一样，但也可以直接写入中断函数，我们这里采用后面的方法。前四个Led灯闪烁，那就是前四个灯亮和灭嘛，异或就好了，后四个同理。

整理一下

```c
if(++Timer_500ms == 500)
	{
		Timer_500ms = 0;
		Flag ^= 1;
		if(Seg_Time[0] >= 12)
		{	
			Led ^= 0xF0;							//^1是取反   ^0是不变		
		}
		else
		{
			Led ^= 0x0F;			
			//低四位变为 1，前四个LED亮；500ms后再执行一次，低四位变回 0，LED灭，形成闪烁
		}
	}
```

然后在Led函数中，实现我们前提条件，闹钟状态是开启，否则灯熄灭，蜂鸣器不叫。 要“到达闹钟设置的时间”，得用个变量纪录这个状态，然后开始亮灯，蜂鸣器开始叫。

```c
if(Alarm_Flag == 1)
	{
		//只有这一秒才符合要求，下一秒就不符合要求了，所以还要个变量纪录这个状态
		if(Seg_Time[0] == Alarm_Set[0] && Seg_Time[1] == Alarm_Set[1]  && Seg_Time[2] == Alarm_Set[2])
			Alarm_Enable_Flag = 1;
		if(Alarm_Enable_Flag == 1)
		{
			P2_3 = 0;
			P1 = Led;
		}
		else
		{
			P2_3 = 1;
			P1 = 0xFF;
		}
	}
	else
	{
		P2_3 = 1;
		P1 = 0xFF;
	}
```

至此整体结束。



### 决赛过渡一: Led彩灯控制系统

一、题目：

![image-20250329154547493](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250329154547493.png)

![image-20250401155516494](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250401155516494.png)

![image-20250401155542648](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250401155542648.png)

![image-20250401155600024](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250401155600024.png)

![image-20250401155612962](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250401155612962.png)

一般都是以数码管入手，但是这道题比较特殊，以模式入手比较好

四个模式——创建变量Led_Mode

二、**彩灯设计：**

![image-20250329142918685](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250329142918685.png)

![image-20250329141521316](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250329141521316.png)

定义系统计时变量Sys_Tick,在中断中每400ms加1，每当我的计数值达到一个数字的时候，让计数值复位，根据模式的不同，选择不同的彩灯运行方式。

模式一、二都简单，用crol和cror就行

模式三、四的话我们可以提前创建一个数组，将哪些灯要亮写成一个数组之后，存放到一个数组里  18、27、36、45亮   正序就是模式3 倒序就是模式4  ucLed_Data[4] = {0x7e,0xbd,0xdb,0xe7}

所以模式三四就是跑数组，数组索引溢出后跳转到下一模式

![image-20250329141331853](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250329141331853.png)

循环间过渡也要注意一下  模式1-模式2 模式2-模式3 都比较简单，只要看是否运行到最后一位，运行到最后一位的话，就跳转下一个模式就行 

模式3-模式4 就是看索引，索引溢出后就是模式4了

模式4-模式1 两边都要设置  首先模式4索引溢出后跳转模式1，索引复原   模式1那边得判断，如果是0x7e（即第1、第8个灯亮），**那先让第一个灯亮，下一次进来才继续移位（第二个灯亮、第三个灯亮...）**

**就是_crol_()函数显示的时候第一个灯不会亮，直接从第二个灯亮了，else作用就是让第一个灯亮,避免模式4到模式1忽略了L1**



![image-20250329153707543](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250329153707543.png)

三、**流转时间**：

**四个模式应该有自己可调整的流转时间，而不是一个变全部都变**。首先定义一个流转时间的数组，Led_Time_Data[4]={400,400,400,400},然后配合Led_Mode对不同模式进行流转时间的调整

Led_Time_Data[Led_Mode]正是当前模式设置的流转时间	



四、**数码管部分**:

![image-20250329154547493](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250329154547493.png)

![image-20250329161026689](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250329161026689.png)

见2，数据显示界面只有在运行状态界面长按才有用，所以说明了运行状态界面是包括了两个界面，两个变量

首先多界面，定义多模式切换变量 Seg_Disp_Mode,0是运行状态界面，1是流转时间变量，2是数据显示变量

见运行状态界面，运行状态可以用一个变量表示，运行模式已经用Led_Mode定义了，流转间隔我们已经写了数组，也好写

详细部分： 运行状态——System_Flag 0系统暂停 1系统启动，默认为0     在数码管显示函数中，我们就可以开始写了

![image-20250329164208143](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250329164208143.png)

```c
/*Seg.c内*/
unsigned char Seg_Dula[] = {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x00,0x77,0x40};//数码管段码储存数组,11是S的段码，12是R的段码
unsigned char Seg_Wela[] = {0xfe,0xfd,0xfb,0xf7,0xef,0xdf};//数码管位码储存数组
void Seg_Proc()
{
    
    if(Seg_Slow_Down) return;
    Seg_Slow_Down = 1;
    
    switch(Seg_Disp_Mode)
    {
        case 0 ://运行状态显示界面
            
            Seg_Buf[0] = System_Flag ? 11 : 12; //11-S 12-R 
    		Seg_Buf[1] = Led_Mode+1;
            Seg_Buf[2] = Led_Time_Data[Led_Mode] / 1000 % 10;
            Seg_Buf[3] = Led_Time_Data[Led_Mode] / 100 % 10;
            Seg_Buf[4] = Led_Time_Data[Led_Mode] / 10 % 10;
            Seg_Buf[5] = Led_Time_Data[Led_Mode]  % 10;
        break;
    }
}
```

**高位未启用数码管熄灭怎么办呢**，这里是因为只有最高位可能熄灭，所以我们这样写

```c
if(Seg_Buf[2] == 0) Seg_Buf[2] = 10;
```

但是难一点很可能是好几位都可能为0，所以我们要换种方式

```c
unsigned char i = 2;//流转时间间隔的最高位
while(Seg_BUf[i] == 0)
{
    Seg_Buf[i] = 10;
    i++;
}
```

综合：

```c
/*Seg.c内*/
unsigned char Seg_Dula[] = {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x00,0x77,0x40};//数码管段码储存数组,11是S的段码，12是R的段码
unsigned char Seg_Wela[] = {0xfe,0xfd,0xfb,0xf7,0xef,0xdf};//数码管位码储存数组
/*main函数内*/
void Seg_Proc()
{
    unsigned char i = 2//流转时间间隔的最高位
    if(Seg_Slow_Down) return;
    Seg_Slow_Down = 1;
    
    switch(Seg_Disp_Mode)
    {
        case 0 ://运行状态显示界面
            
            Seg_Buf[0] = System_Flag ? 11 : 12; //11-S 12-R 
    		Seg_Buf[1] = Led_Mode+1;
            Seg_Buf[2] = Led_Time_Data[Led_Mode] / 1000 % 10;
            Seg_Buf[3] = Led_Time_Data[Led_Mode] / 100 % 10;
            Seg_Buf[4] = Led_Time_Data[Led_Mode] / 10 % 10;
            Seg_Buf[5] = Led_Time_Data[Led_Mode]  % 10;
         	while(Seg_BUf[i] == 0)
            {
                Seg_Buf[i] = 10;
                i++;
            }
            
        break;
    }
}
```

下一个到流转时间的设置界面，由于不好跳转了，所以写完第一个界面我们就先写按键了。

![image-20250329164543973](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250329164543973.png)



五、按键

![image-20250329164810048](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250329164810048.png)

S7： 

![image-20250329164937654](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250329164937654.png)

![image-20250329164851044](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250329164851044.png)

S6: 只能在系统处于停止状态时使用

![image-20250329164951816](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250329164951816.png)

**逻辑是运行状态界面 - S6按完模式编号闪 -S6按完流转间隔闪 -S6按完保存状态退出到运行状态界面**

只有在模式编号和流转间隔保存后，才把设置好的这些数真正保存

我们先设置一个流转数据临时数组Led_Time_Set[4]，保存我们中途设置的这些值，如果后面没有真正保存，那就不要了

在第一次按下按键后，保存当前显示界面的数据，就跳到流转时间设置界面了

![image-20250329171503858](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250329171503858.png)

底层段码Seg_Dula[]的13是 -  ，对应图片中第一位

**这里要注意**：看到Seg_Buf[1] = Led_Time_Set_Index+1,

跳转到不同Led模式的变量和流转时间设置界面的变量不能一样，它们应该是两个不同的系统，即进入到流转时间设置界面设置时，不影响现在的跳转Led模式变量Led_Mode  否则就会出现设置完Led直接从模式2开始运行了这种情况

![image-20250330213218885](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250330213218885.png)

现在到被选中的单元以0.8s闪烁了，

![image-20250330210500910](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250330210500910.png)

那先设置一个标志位Set_Flag,0代表在设置模式编号，1代表在设置流转间隔,

然后是数码管闪烁标志位Seg_Star_Flag，然后是Timer_400Ms

那就是经典的以400ms周期亮灭一次了，在中断函数中，

```c
void Timer0Server() interrupt 1
{
    if(++Timer_400Ms == 400)
    {
        Timer_400Ms = 0;
        Seg_Star_Flag ^= 1;
    }
}
```

在数码管显示函数中，第一步就是让所有值都正常显示，然后将要闪烁的部分覆盖就好，加上最高位的熄灭，我们能得到

![image-20250330213456806](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250330213456806.png)

然后看到加减按键

![image-20250330213926516](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250330213926516.png)

首先在设置界面下  ————if(Seg_Disp_Mode == 1)

然后看是运行模式还是流转间隔 ———— if(Set_Flag == 0 / 1) 

运行模式下编号加1————if（++Led_Time_Set_Index == 4)   Led_Time_Set_Index = 0

流转时间间隔下 加 100ms   ————Led_Time_Set[Led_Time_Set_Index] = Led_Time_Set[Led_Time_Set_Index]+100

上下限 400-1200  ———— if(Led_Time_Set[Led_Time_Set_Index] >= 1300)  Led_Time_Set[Led_Time_Set_Index] = 400

![image-20250330223924114](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250330223924114.png)

难的还有一步，S6最后一步按键保存

注意我们S6的顺序是 **运行状态界面——流转时间界面的模式编号闪烁——流转时间界面的流转间隔闪烁——保存，退出到运行状态界面**

这是第一次按下，我们第二次按下会跳转到流转时间界面

![image-20250330224542774](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250330224542774.png)

但是不能写if(Seg_Disp_Mode == 1){...}，而该写**else if**(Seg_Disp_Mode == 1){...}

否则Seg_Disp_Mode == 1下面的内容就会执行两次，会导致直接跳转到流转间隔闪烁

Set_Flag默认是0，也就是第一次按下后模式编号就开始闪了，然后第二次按下，进入else if ，流转间隔闪，第三次按下，进入else if，

满足if（Set_Flag ==0）,保存，回到运行状态界面

![image-20250330230336258](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250330230336258.png)



还有一个长按跳转界面没写

![image-20250331111348348](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250331111348348.png)

系统停止状态————之前定义了System_Flag，0是暂停，1是启动

只有数据显示界面才能看系统是否暂停，加上长按S4跳转的条件

————if(Key_Old == 4 &&Seg_Disp_Mode == 0)

由于要跳转数据显示界面且数据显示界面不单独出现（只有长按出现），所以可以设置数据显示标志位，Data_Disp_Flag,0表示不显示，1表示显示（当然你在Seg_Disp_Mode多加一个数据显示界面我觉得也行）

Key_Proc()中

![image-20250331143822206](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250331143822206.png)

Seg_Proc()中

![image-20250331143416471](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250331143416471.png)





### 过渡题：电压采集器

前言：

**蓝桥杯内只有P0口，所以写led的时候会对他重复赋值，是会出问题的，所以我们出现了Led的底层函数**

##### Led	

通过维护一个内部状态来优化端口操作，避免频繁或重复地写入硬件端口（如P1），从而提升效率并确保各LED状态独立

```c
#include <Led.h>

void Led_Disp(unsigned char addr,enable)
{
	static unsigned char temp = 0x00; //用于记录当前所有LED的状态
	static unsigned char temp_old = 0xff;	//保存上一次的LED状态，用于比较是否需要更新硬件端口
	if(enable)
		temp |= 0x01 << addr;	
	else
		temp &= ~(0x01 << addr);
	//比较当前状态 temp 和上一次状态 temp_old，仅当状态变化时，才更新端口值，避免重复写入
	if(temp != temp_old) 
	{
		P1 = ~temp;
		temp_old = temp;
	}
}

```







题目：

![image-20250401155418774](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250401155418774.png)

![image-20250401155917174](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250401155917174.png)

![image-20250401155936644](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250401155936644.png)

![image-20250401155957920](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250401155957920.png)







讲解+重点：

我们还是从数码管开始

![image-20250401160354078](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250401160354078.png)

四个界面————unsigned char Seg_Disp_Mode;//数码管显示模式标志位 0-电压采集 1-数据显示 2-参数设置 3-计数统计

电压采集界面————

```C
unsigned char Seg_Input[4] = {11,11,11,11};//数码管输入数据储存数组,11对应Seg_Dula[]中的"-"

unsigned char Seg_Input_Index;//数码管输入数据储存数组指针
unsigned char Key_Error_Count;//无效按键统计变量
```

然后按键S1-S10是键盘0-9输入,那我们进入到Key_Proc()中，我们还注意到有个无效操作的纪录指标，那也可以顺便纪录了。

```c
if(Key_Down >= 1 && Key_Down <= 10)
{
    if(Seg_Input_Index < 4 && Seg_Disp_Mode == 0)
    {
        Seg_Input[Seg_Input_Index] = Key_Down - 1;
        Seg_Input_Index++;
    }
    else
        Key_Error_Count++;
}
```

"当前输入数码管以0.5S/次闪烁"，即以0.5s为周期亮

```c
unsigned int Timer_500Ms;//五百毫秒计时变量
bit Seg_Flag;//数码管闪烁标志位
```

在中断函数中

```c
if(++Timer_500Ms == 500)
	{
		Timer_500Ms = 0;
		Seg_Flag ^= 1;
	}
```

在Seg_Proc()中  需要注意到输入电压到最后一位输完时就不闪了，免得指针溢出了

```c
void Seg_Proc()
{
  unsigned char i;//用于For循环
  switch(Seg_Disp_Mode)
	{  
        case 0://电压采集界面
            Seg_Buf[0] = Seg_Buf[1] = 10;//前两位熄灭
            for(i = 0;i<=4;i++)
            {
                Seg_Buf[2+i] = Seg_Input[i];
            }
            if(Seg_Buf[5] == 11)
            {
                Seg_Buf[2+Seg_Input_Index] = Seg_Flag ? Seg_Buf[2+Seg_Input_Index]:10;
          break;
        }
  	}
}
```

"例如：输入电压 2588mV，则实际电压为 2.58V（结果保留两位小数"

![image-20250401164003465](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250401164003465.png)

我们采用比较方便的**四舍五入**的方法：输入完电压后我们会得到Seg_Input[4]数组，我们将它复原成四位数，加上5，最后还原取前三位就是我们想要的答案

```c
float Voltage;//实际电压变量
```

在Key_Proc()中

```c
void Key_Proc()
{
    switch(Key_Down)
    {
        case 11:
            if(Sep_Disp_Mode == 0)
            { 
                    Voltage = Seg_Input[0]*1000 + Seg_Input[1]*100 + Seg_Input[2]*10 +Seg_Input[3] + 5 / 1000.0;//要最终想得到浮点数的形式，那也要除以浮点数1000.0
                    Sep_Disp_Mode = 1;
                
    }
}
```

在Seg_Proc()中

```c
void Seg_Proc()
{
     switch(Seg_Disp_Mode)
	{
         case 1://数据显示界面
             Seg_Buf[0] =  12  ;//提示符
    		 Seg_Buf[1] = Seg_Buf[2] = 10;//熄灭
             Seg_Buf[3] = (unsigned int)Voltage ;
             Seg_Buf[4] = (Voltage*100) /10 %10 ;
             Seg_Buf[5] = Voltage%10 ;
             
    }	
}
```

基础的写完了，现在考虑一些临界情况，比如输入9999，那我们要显示的是10.0V，而这样小数点就跑到第二位上了，所以我们要在小数点点位上思考一下

还有就是变成10之后，Seg_Buf[3]就不能单纯使用(unsigned int)Voltage，所以得/10看看是不是等于1，如果是0不是1的话就让(unsigned char)Voltage % 10就行

```c
unsigned char Seg_Point[6] = {0,0,0,0,0,0};//数码管小数点显示数组
```

在Seg_Proc()中

```c
void Seg_Proc()
{
     switch(Seg_Disp_Mode)
	{
         case 1://数据显示界面
             Seg_Point[3+Voltage/10] = 1; //小数点
             
         	 Seg_Buf[0] =  12  ;//提示符
    		 Seg_Buf[1] = Seg_Buf[2] = 10;//熄灭
             Seg_Buf[3] = (unsigned int)Voltage /10 ?1 :(unsigned char)Voltage % 10 ;
             Seg_Buf[4] = (unsigned int)(Voltage*100) /10 %10 ;
             Seg_Buf[5] = (unsigned int)(Voltage*100) %10 ;
         break;    
    }	

}
```

"在电压采集界面按下 S11 后保存当前输入电压值，并返回电压显示界面（若输入数据不符合规范性，则清空数据重新输入)"

"按键 S11：电压采集按键，按下 S11 后进入电压采集界面，可重新采集一次电压值“

综合一下，我们给出最终版本

在Key_Proc()中

```c
void Key_Proc()
{
    switch(Key_Down)
    {
        case 11:
            if(Sep_Disp_Mode == 0)
            {
                if(Seg_Input_Index >= 4)
                {
                    Voltage = Seg_Input[0]*1000 + Seg_Input[1]*100 + Seg_Input[2]*10 +Seg_Input[3] + 5 / 1000.0;//要最终想得到浮点数的形式，那也要除以浮点数1000.0
                    if(Voltage >= 0.01)
                    	Sep_Disp_Mode = 1;
                     else
                	{
                        for(i = 0;i<=4;i++)//输入数组复位
                        {
                            Seg_Input[i] = 11;
                        }
                        Seg_Input_Index = 0;//输入指针复位
                	}
                }
                 else
                {
                    for(i = 0;i<=4;i++)//输入数组复位
                    {
                        Seg_Input[i] = 11;
                    }
                    Seg_Input_Index = 0;//输入指针复位
                }
               
            }
            else
            {
                Sep_Disp_Mode = 0;
                Seg_Input_Index = 0;//输入指针复位
                for(i = 0;i<=4;i++)//输入数组复位
                    {
                        Seg_Input[i] = 11;
                    }
                   
            }
            
    }
}
```

我的错误地方：

1.if(Seg_Input_Index >= 4) 我写的小于，边界值判断错误

2.Voltage最小边界未确定，如果输入四个0应该被当做错误数据，所以要加上if(Voltage >= 0.01)  ，并加上else部分（虽然我自己感觉四个0ok，毕竟范围是0-10v）

3.在输入数组复位部分，我用Seg_Buf[2+i] = 11;代替了Seg_Input[i] = 11;   这样是有问题的，这会导致下次进入电压采集界面时数据残留，正确做法是就用Seg_Input[i] = 11; 然后等进入电压采集界面时，让其中的代码自动更新Seg_Buf[2+i] 。



来到参数设置界面，也是十分简单的

![image-20250401174048078](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250401174048078.png)

```c
float Voltage_Parameter = 3.0;//电压设置参数
```

在Seg_Proc()中

```c
void Seg_Proc()
{
    switch(Seg_Disp_Mode)
	{
            case 2://参数设置界面
            Seg_Point[3+(int)Voltage/10] = 1; 
			Seg_Buf[0] = 13;	//标识符
			Seg_Buf[1] = Seg_Buf[2] = 10;
			Seg_Buf[3] = (unsigned char)Voltage_Parameter % 10;
			Seg_Buf[4] = (unsigned int)(Voltage_Parameter * 100) / 10 % 10;
			Seg_Buf[5] = (unsigned int)(Voltage_Parameter * 100) % 10;	
            break;
    }
}
```

计数统计界面

![image-20250401174659109](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250401174659109.png)

用到我们之前讲到的“高位未启用数码管熄灭”的知识

当然不要忘记让小数点归0

```c
unsigned int Count;// 计数值专用变量
```

```c
void Seg_Proc()
{	
    unsigned char j = 1;//用于While循环
    switch(Seg_Disp_Mode)
	{
            case 3://计数统计界面
          	Seg_Point[3+(int)Voltage/10] = 0;
			Seg_Buf[0] = 14;	//标识符
            Seg_Buf[1] = Count / 10000 % 10;
		 	Seg_Buf[2] = Count / 1000 % 10;
			Seg_Buf[3] = Count / 100 % 10;
			Seg_Buf[4] = Count / 10 % 10;
			Seg_Buf[5] = Count % 10;
			while(Seg_Buf[j] == 0 && j<5)
            {
                Seg_Buf[j] = 10;
                j++;   
            }
    }
}
```





紧接着来处理一下我们计数值加1条件

![image-20250404153432924](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250404153432924.png)

意思是第一次实际电压超过设置值时      重输入后实际电压小于设置值时加1，那同样的，我们要用一个新的变量存设置值，这个设置值暂时仅用于计数值触发，一直不变

也需要一个标志位来看这是重输入前还是后

```c
float Voltage_Parameter_Ctrol = 3.0;//实际电压设置参数  默认值3.0V
bit Voltage_Flag ;//电压参考标志位
/*在Seg_Proc()中*/
Void Seg_Proc()
{
	if(Voltage > Voltage_Parameter_Ctrol)
    {
 		Voltage_Flag = 1;//拉高标志位
        Count++;
    }
    else if(Voltage_Flag == 1)
    //等效于if(Voltage > Voltage_Parameter_Ctrol && Voltage_Flag == 1)
    {
            Voltage_Flag = 0;//标志位复位
            Count++;//计数值+1
    }		
}
```







“按键 S12：界面切换按键，按下 S12 后可在数据显示-参数设置-计数统计三个 界面中循环切换"

```c
void Key_Proc()
{
    switch(Key_Down)
    {
        case 12:
            if(Seg_Disp_Mode != 0)
            {
				if(Seg_Disp_Mode == 2)
					Voltage_Parameter = Voltage_Parameter_Ctrol;//保存当前设置参数
				if(++Seg_Disp_Mode == 4)
					Seg_Disp_Mode = 1;
            }
            else
				Key_Error_Count++;
		break;
    }
}
```

“按键 S14：清零参数按键，在电压采集界面按下 S14 可清除当前输入数据，在 计数统计界面可清除当前计数值”

```c
void Key_Proc()
{
    switch(Key_Down)
    {
        case 14:
            if(Seg_Disp_Mode == 0)
            {
                Seg_Input_Index = 0;//输入指针复位
                for(i = 0;i<4;i++)//输入数组复位
                {
                    Seg_Input[i] = 11;
                }
            }
            else if(Seg_Disp_Mode == 3)
            {
              Count = 0;
			}
            else
                Key_Error_Count++;
        break;
    }
}
```

"按键 S15：参数+按键，按下 S15 后，电压参数+0.5V，达到上限 6V 后回到下限 1V"

```c
void Key_Proc()
{
    switch(Key_Down)
    {
        case 15:
    		if(Seg_Disp_Mode == 2)
            {
				Voltage_Parameter += 0.5;
				if(Voltage_Parameter > 6)
					Voltage_Parameter = 1;
			}
			else
				Key_Error_Count++;
		break;   
    }
}
```

"按键 S16：参数-按键，按下 S16 后，电压参数-0.5V，达到下限 1V 后回到上 限 6V"

```c
if(Seg_Disp_Mode == 2)//处于参数设置界面
			{
				Voltage_Parameter -=0.5;
				if(Voltage_Parameter < 1)
					Voltage_Parameter = 6;
			}
			else
				Key_Error_Count++;
		break;
```

当我们像上面一样把Led模块做好之后，这些就迎刃而解了

![image-20250404160500299](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250404160500299.png)

```c
unsigned int Sys_Tick;//系统计时器
unsigned char ucLed[8] = {0,0,0,0,0,0,0,0};//Led显示数据存放数组
/*中断函数中*/
void Timer0Server() interrupt 1
{
    if(++Led_Pos == 8) Led_Pos = 0;
    Led_Disp(Led_Pos,ucLed[Led_Pos]);
    if(Voltage < Voltage_Parameter_Ctrol)
		Sys_Tick++;
}
/*Led_Proc()中*/
void Led_Proc()
{
	if(Voltage < Voltage_Parameter_Ctrol)
	{
		if(Sys_Tick >= 5000)
			ucLed[0] = 1;
	}
    else
	{
		Sys_Tick = ucLed[0] = 0;
	}
    ucLed[1] = Count % 2;
	ucLed[2] = Key_Error_Count / 3;
}
```

关于指示灯L3，我们在有效操作（即那些按钮部分）加一个Key_Error_Count = 0;，在它们的else部分（无效操作）加一个Key_Error_Count++;就行







### 过渡题2：模拟温度采集器

![image-20250404163803466](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250404163803466.png)

![image-20250404163816440](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250404163816440.png)

![image-20250404163828756](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250404163828756.png)

![image-20250404163842196](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250404163842196.png)

![image-20250404163855710](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250404163855710.png)

![image-20250404163907639](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250404163907639.png)





##### **如何实现小数点输入？**

![image-20250404163946839](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250404163946839.png)

![image-20250404164037264](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250404164037264.png)

首先 必须在温度采集界面才能按  ——Seg_Disp_Mode == 0

其次  第一个数输入完才能按 ——Seg_Input[0] != 11

然后   不能一直按  —— 标志位，Point_Flag  == 0

**我建议加上 Seg_Input_Index < 3，老师讲解是没加的。免得出现234.这种数据，虽然后面有个(unsigned char)Temperature > 85 筛选掉了**

Seg_Point[2+Seg_Input_Index] = 1;

输入完小数点后直接拉高Point_Flag  == 1，一次采集只能输入一次小数点 	

```C
case 11://小数点输入
			if(Seg_Disp_Mode == 0 && Point_Flag == 0 && Seg_Input[0] != 11)//处于温度采集界面、标志位为0、输入数组第一位有数据
			{
				Seg_Point[2+Seg_Input_Index] = 1;
				Point_Wela = Seg_Input_Index;//记录此时指针状态 便于后期数据处理
				Point_Flag = 1;//拉高标志位 保证一次输入周期小数点只能使能一次
			}
		break;
```

##### **输入完如何保存温度数据？**

![image-20250404170727834](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250404170727834.png)

![image-20250404170636283](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250404170636283.png)

------

我想的是出一个索引Point_Wela纪录小数点状态，一个浮点数纪录最终结果然后switch判断

如果是case 1  那在第一个位置  我们把Seg_Point里面的三个数字先变成三位数，再除100

case 2  第二个位置  一样   变成三位数再除10

```c
Point_Wela = Seg_Input_Index;//记录此时指针状态 便于后期数据处理
```

------



先看看不是温度采集界面的时候，就是索引和输入数组复位

```c
if(Seg_Disp_Mode != 0)//处于非温度采集界面
			{
				Seg_Input_Index = 0;//指针复位
				Point_Flag = 0;//小数点输入标志位复位
				for(i = 0;i < 3;i++)//数组复位
					Seg_Input[i] = 11;
				Seg_Disp_Mode = 0;//进入温度采集界面
			}
```

接下来在温度界面中

由于温度范围是0-85°c，所以没有小数点（Point_Flag = 0）或者指针没到3（没输入完），肯定是无效数据 

除了上面的

索引复位    小数点标志位复位   Seg_Input复位   外，加一个小数点复位  

```C
if(Point_Flag == 0 || Seg_Input_Index < 3)//若小数点没有使能 或者指针不为3 则一定为无效数据
				{
					Seg_Input_Index = 0;//指针复位
					Seg_Point[3] = Seg_Point[4] = 0;//小数点复位
					Point_Flag = 0;//小数点输入标志位复位
					for(i = 0;i < 3;i++)//数组复位
						Seg_Input[i] = 11;
				}
```

ok，到处理数据（四舍五入）以及三位数加小数点的部分了

```C
float Temperature;//实际温度变量
Temperature = Seg_Input[0] * 100 + Seg_Input[1] * 10 + Seg_Input[2] + 5;
while(3 - Point_Wela)
{
	Temperature /= 10.0;
	Point_Wela++;
}
```

老师这里加小数点的部分复杂了，用if和我的switch方法也OK的



整体温度采集如下

```c
case 16://温度采集
			if(Seg_Disp_Mode != 0)//处于非温度采集界面
			{
				Seg_Input_Index = 0;//指针复位
				Point_Flag = 0;//小数点输入标志位复位
				for(i = 0;i < 3;i++)//数组复位
					Seg_Input[i] = 11;
				Seg_Disp_Mode = 0;
			}
			else//处于温度采集界面
			{
				if(Point_Flag == 0 || Seg_Input_Index < 3)//若小数点没有使能 或者指针不为3 则一定为无效数据
				{
					Seg_Input_Index = 0;//指针复位
					Seg_Point[3] = Seg_Point[4] = 0;//小数点复位
					Point_Flag = 0;//小数点输入标志位复位
					for(i = 0;i < 3;i++)//数组复位
						Seg_Input[i] = 11;
				}
				else//小数点使能 进行范围判断
				{
					Temperature = Seg_Input[0] * 100 + Seg_Input[1] * 10 + Seg_Input[2] + 5;
					while(3 - Point_Wela)
					{
						Temperature /= 10.0;
						Point_Wela++;
					}
					if((unsigned char)Temperature > 85)//超出采集上限值
					{
						Seg_Input_Index = 0;//指针复位
						Seg_Point[3] = Seg_Point[4] = 0;//小数点复位
						Point_Flag = 0;//小数点输入标志位复位
						for(i = 0;i < 3;i++)//数组复位
							Seg_Input[i] = 11;						
					}
					else//数据合理
					{
						Seg_Input_Index = 0;//指针复位
						Seg_Point[3] = Seg_Point[4] = 0;//小数点复位
						Point_Flag = 0;//小数点输入标志位复位
						Seg_Disp_Mode = 1;//跳转到数据显示界面
					}
				}
			}
		break;
```



##### **加减按钮以及长按快速加减（长按短按不同功能？）**

![image-20250405151636316](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250405151636316.png)

![image-20250405151646691](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250405151646691.png)

![image-20250405152212403](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250405152212403.png)



这里必须用Key_Up

```c
Key_Val = Key_Read();
Key_Down = Key_Val &(Key_Old ^ Key_Val);
Key_Up = ~Key_Val &(Key_Old ^ Key_Val);//捕捉按键上升沿
Key_Old = Key_Val;
```

为什么不能用Key_Old?   因为我们按下的那一瞬间Key_Down和Key_Old其实是一个值，也就是不管你长不长按，我的短按已经执行了，这样是不行的。

来看看如何做

1.参数设置界面下，按下S14、S15后（Key_Down），标志位启动，开始计时：  在500ms内有抬起动作（Key_Up）,算作短按，标志位和计数用的变量复位，只加1或减1，直到达到上限值或下限值做处理  ；

  超过500ms后无抬起动作，算作长按，一直加直到达到上限值或下限值做处理，如果检测到抬起，标志位和计数用的变量复位。

2.防止有人很抽象的按S14和S15这个超过了65535秒，超过了int的范围，所以可以在计数变量上限制一下，只能自加到600ms，而后一直让它等于600ms，直到不长按后被复位。

```c
unsigned int Count_500Ms;//五百毫秒计数变量
/*中断函数中*/
if(Time_Flag == 1)
	{
		if(++Count_500Ms == 600)//自加到五百毫秒以上就可以限制住 防止一直按下自加的时候数值越界
			Count_500Ms = 600;
	}
/*Key_Val中*/
if(Seg_Disp_Mode == 2)//处于参数设置界面
	{
		if(Key_Down == 14)//S14按下
			Time_Flag = 1;//计时开始
	}
	if(Count_500Ms < 500)//短按
	{
		if(Key_Up == 14)//S14抬起
		{
			Time_Flag = Count_500Ms = 0;//状态复位
			if(++Parameter[Parameter_Index] > 70)//超过上限值
				Parameter[Parameter_Index] = 10;
		}
	}
	else//长按
	{
		if(Key_Old == 14)//S14长按
		{
			if(++Parameter[Parameter_Index] > 70)//超过上限值
				Parameter[Parameter_Index] = 10;
		}
		if(Key_Up == 14)//S14抬起
			Time_Flag = Count_500Ms = 0;//状态复位
	}
```

可能上仿真后会发现长按的时候是间隔一段时间才显示，很卡，是因为我们在中断中数码管是500ms刷新一次，而键盘输入是10ms刷新一次，只要都调到10ms就不会卡顿了

![image-20250405155156906](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250405155156906.png)



##### **Led亮度等级（闪烁与亮度）**

比如一条线，全亮的话亮度是100%，亮一半亮度是50%

![image-20250405155659620](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250405155659620.png)

那它和闪烁有什么区别呢？

**闪烁设置的周期比较长，肉眼看到的就是闪烁；亮度设置的周期比较短，肉眼看到的就是亮度** 

![image-20250405161047166](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250405161047166.png)

那我们就设置一个亮度等级计数的变量Led_Num，一个纪录亮度等级是多少的变量Led_Pwm(比如等于3是1级，等于6是2级..)

先在Led_Proc()中写好限制条件，最后在中断中施行：Led_Num没达到指定的数字前，一直亮，达到后熄灭。

```c
unsigned char Led_Num;//Led亮度等级计数变量
unsigned char Led_Pwm;//Led亮度等级
/*在中断中*/
if(++Led_Num == 10) Led_Num = 0;
	if(Led_Num < Led_Pwm)
		Led_Disp(Led_Pos,ucLed[Led_Pos]);
	else
		Led_Disp(Led_Pos,0);
/*在Led_Proc()中*/
if(Temperature > Parameter_Ctrol[0])
		Led_Pwm = 3;
	else if(Temperature < Parameter_Ctrol[0] && Temperature > Parameter_Ctrol[1])
		Led_Pwm = 6;
	else
		Led_Pwm = 9;
```

Led函数再复习一遍~

```c
void Led_Disp(unsigned char addr,enable)
{
    static unsigned char temp = 0x00;
    static unsigned char temp_Old = 0x00;
    if(enable)
    {
		temp |= 0x01 << addr;
    }
    else
        temp &= ~(0x01 << addr);
	if(temp != temp_old)
    {
		P1 =~temp;
        temp_old = temp;
    }
}
```



简单的我们就一起复习一下，主要是注意一些易错的点

界面切换

```C
unsigned char Parameter[2] = {30,20};//参数设置数组，用来显示界面的数组
unsigned char Parameter_Ctrol[2] = {30,20};//实际参数控制数组，用于后面LED比大小的，保存的是有效数据
```

![image-20250405163006393](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250405163006393.png)

![image-20250405164440333](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250405164440333.png)

![image-20250405163012981](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250405163012981.png)

就两个界面切换，所以if条件是if(Seg_Disp_Mode != 0)	

由于后面Led显示部分要看参数设置的是否合理，所以我们设置一个标志位Error_Flag纪录一下

从数据显示切换到参数设置没有参数检查要求，我们先写  

数据显示到参数设置，将选择TMAX或者TMIN的指针归0，用Parameter_Ctrol[2]将Parameter[2]复位

参数设置到数据显示，首先检查TMAX是否≥TMIN，且TMAX和TMIN都在规定的范围之内：不在，标志位＝1，（根据要求，这里不用Parameter_Ctrol[2]将Parameter[2]复位，我们在参数设置界面还需要显示，等到数据显示界面进入参数设置界面的时候，我们再复原）；

在，将Parameter[2]数据赋值给Parameter_Ctrol[2]，数据设置成功

```c
case 12://界面切换
			if(Seg_Disp_Mode != 0)//处于非温度采集界面
				Seg_Disp_Mode = Seg_Disp_Mode==1?2:1;
			if(Seg_Disp_Mode == 2)//切换到参数设置界面时
			{
				Parameter_Index = 0;//指针复位
				Parameter[0] = Parameter_Ctrol[0];//数据复位
				Parameter[1] = Parameter_Ctrol[1];
			}
			else//切换到数据显示界面
			{
				if(Parameter[0] >= Parameter[1] && Parameter[0] <= 70 && Parameter[1] >= 10)//合理设置参数
				{
					Error_Flag = 0;
					Parameter_Ctrol[0] = Parameter[0];//设置生效
					Parameter_Ctrol[1] = Parameter[1];
				}
				else
					Error_Flag = 1;
			}
		break;
```



点亮LED灯

![image-20250405170331197](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250405170331197.png)

![image-20250405170343817](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250405170343817.png)

我们写了LED的底层后这个就比较简单了

当前温度就是输入的温度Temperture，合规的TMAX和TMIN我们用Parameter_Ctrol[0]纪录了

可得

```c
/*Led_proc()中*/
ucLed[0] = (int)Temperature / Parameter_Ctrol[0];
	ucLed[1] = (!((int)Temperature / Parameter_Ctrol[0])) & ((int)Temperature / Parameter_Ctrol[1]);
	ucLed[2] = !((int)Temperature / Parameter_Ctrol[1]);
	ucLed[3] = Error_Flag;
```

这里的方法比较巧妙，其实用if判断也行





### 蓝桥杯部分

#### 添加芯片包

打开STC-ISP 选中Keil仿真设置-找到单片机型号**IAP15F2K60S2**（用K61S2替代一样）——点击添加型号和头文件到Keil中——添加完后就可以使用芯片包了

![image-20250405171753254](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250405171753254.png)

如果有MDK的加到MDK文件夹里，不然识别不到

![image-20250406141253406](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250406141253406.png)



原理图部分

Led一端接的VCC，那说明另一端Q1-Q8要接低电平才能亮（即给0才能亮）

![image-20250405172038357](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250405172038357.png)

#### 锁存器&原理部分

M74HC573是锁存器，讲它之前，来了解一下别的

![image-20250405172235986](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250405172235986.png)

结论如下：

------

R端（Reset）和S端（Set）都是输入端

如果两个输入端都是0，锁存器不使能，Q是多少数据就是多少

如果两个输入端不一样（一个是1一个是0），S端（Set）是多少，Q就是多少

如果两个输入端都是1，不研究，有问题

------

如何避免两个输入端都是1的情况呢？

前面加了一点东西

![image-20250405173054311](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250405173054311.png)

E（Enable） = 0，不使能，Q是啥值就是啥值

E（Enable） = 1，使能，D是啥值Q就是啥值



回到M74HC573

![image-20250405174130747](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250405174130747.png)

LE相当于一扇门，LE置1时门打开，来自上面D端的数据才能够到下面Q端

如果LE置0，门关闭，那Q端数据是多少最终结果就是多少



回到原理图

P0端是数据准备区，准备好后需要看LE是多少，LE接的Y4C

![image-20250405174549912](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250405174549912.png)

如图，Y4C在这里。 Y4C要等于1，有取反符号，说明中间要是0，由于是或门，有1为1，（与门是有0为0），所以要全0

<img src="C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250405174724664.png" alt="image-20250405174724664" style="zoom:50%;" />

在蓝桥杯中J13默认接地，所以WR默认是0

![image-20250405175215465](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250405175215465.png)

Y4在74HC138里，74HC138是译码器，那我们看看译码器

![image-20250405175258786](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250405175258786.png)

这个译码器就是用三个端口控制八个端口，类似下图的方式进行控制（8421）![image-20250406130232180](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250406130232180.png)

那Y4就是 1 0 0，对应P27 = 1，P26 = 0，P25 = 0

这样选中，推回去 Y4选中 ，让Y4=0——> Y4C = 1——>锁存器使能，P0的数据就能够进去



## 蓝桥杯模版（二代）

> 固定有 Init.c  Seg.c key.c Led.c  其他部分考到了再加

![image-20250412204123659](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412204123659.png)

板子上电默认使能状态，要先关闭外设 ————  第一个底层Init

#### 1.Init

灯泡全熄灭——P0 = 0xff

译码器中用到了P25~P27，也就是高三位，低五位的数据保持不变

P2 = P2 & 0x1f（保持低五位状态）

下一步需要选中Y4，即让高三位保持1 0 0

P2 = P2 & 0x1f |0x80

用完后将Y4关上

P2 &= 0x1f

同理，先选中蜂鸣器继电器，传递关闭信号；选中其通道；  随后关闭通道

P0 = 0x00

P2 = P2 & 0x1f | 0xa0

P2 &= 0x1f

故第一个底层 Init.c

```c
#include "Init.h"

void System_Init()
{
	P0 = 0xff;
	P2 = P2 & 0x1f | 0x80;
	P2 &= 0x1f;
	P0 = 0x00;
	P2 = P2 & 0x1f | 0xa0;
	P2 &= 0x1f;
}
```

Init.h

```c
#include <STC15F2K60S2.H>

void System_Init();
```



#### 2.Led

Led.c



temp保存当前所有Led的状态，初始为全灭

temp_old保存上一次Led状态，初始为全亮，确保首次调用时能更新硬件

temp != temp_old        ——仅在Led状态变化时我们更新硬件

P2 = P2 & 0x1f | 0x80;——选中锁存器

P2 &= 0x1f;				   ——关闭锁存器



```c
#include "Led.h"

void Led_Disp(unsigned char addr,enable)
{
	static unsigned char temp = 0x00;
	static unsigned char temp_old = 0xff;
	
	if(enable)
	{
		temp |= 0x01 << addr;
	}
	else
	{
		temp &= ~(0x01 << addr);
	}
	if(temp != temp_old)
	{
		P0 = ~temp;
		P2 = P2 & 0x1f | 0x80;
		P2 &= 0x1f;
		temp_old = temp;
	}
}
```

Led.h

```c
#include <STC15F2K60S2.H>

void Led_Disp(unsigned char addr,enable);
```



#### 3.Key

![image-20250406154136456](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250406154136456.png)

看原理图，引脚和按键都是倒着往上看，后四个（P44 P42 P35 P34）是选中哪一列（从左往右选中），

前四个(P33 P32 P31 P30)是选中按键

```c
#include <Key.h>

unsigned char Key_Read()
{
	unsigned char temp = 0;
	P44 = 0;P42 = 1;P35 = 1;P34 = 1;
	if(P33 == 0) temp = 4;
	if(P32 == 0) temp = 5;
	if(P31 == 0) temp = 6;
	if(P30 == 0) temp = 7;
	P44 = 1;P42 = 0;P35 = 1;P34 = 1;
	if(P33 == 0) temp = 8;
	if(P32 == 0) temp = 9;
	if(P31 == 0) temp = 10;
	if(P30 == 0) temp = 11;
	P44 = 1;P42 = 1;P35 = 0;P34 = 1;
	if(P33 == 0) temp = 12;
	if(P32 == 0) temp = 13;
	if(P31 == 0) temp = 14;
	if(P30 == 0) temp = 15;
	P44 = 1;P42 = 1;P35 = 1;P34 = 0;
	if(P33 == 0) temp = 16;
	if(P32 == 0) temp = 17;
	if(P31 == 0) temp = 18;
	if(P30 == 0) temp = 19;
	return temp;
}
```



#### 按键部分补充！

1.仿真中由于主控制芯片用的还是89C52，所以导致按键最下面的引脚还是**P36、P37**，而蓝桥杯STC15F2K60S2按键最下面的引脚是**P44 P42**，切记！

2.仿真打下J5A，松开J5B（如图）是独立按键     松开J5A，打下J5B是矩阵按键

![image-20250406155329206](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250406155329206.png)

2.蓝桥杯板子和仿真一样，也是独立按键加矩阵按键，

如果跳线帽连接的是左和中两个，那就是独立按键，只有S4~S7,

如果连接的是中和右，那就连接的是矩阵按键,全部都有

![image-20250406154811467](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250406154811467.png)



#### 4.Seg

蓝桥杯数码管变八位了，不是六位了，注意一下

![image-20250406155821264](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250406155821264.png)

共阳极与共阴极：共享同一个阳极（电源）与共享同一个阴极（接地）  **共阳极给0是亮    共阴极给1是亮**

**段码如何推出？**  

比赛的时候是共阳极，会给你一个赛点资源包，里面有“共阳极数码管段码表”，里面有0-9的段码，其他就要你自己推了（现在会不会全给不知道，好像A-F也给了） 

逆序推 ，以共阳极为例（0是亮） dp g f e d c b a 看图中数字2怎么来的，自己想

数码管原理

右边有abcdefgdp,所以Y7C对应段选锁存器  那Y6C就是位选锁存器



![image-20250406161802915](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250406161802915.png)

Y7  1110 0000 0xe0  Y6 1100 0000 0xc0

小数点是第八位，也就是最高位 0111 1111  0x7f   那怎么让最高位为0，用&

整体逻辑：

1.P0熄灭 段选开关门

2.P0=位码 位选开关门

3.P0=段码 if(point) P0 &= 0x7f; 位选开关门

```c
#include <Seg.h>


unsigned char seg_dula[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xff,0x88};
unsigned char seg_wela[] = {0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};

void Seg_Disp(unsigned char wela,dula,point)
{
	P0 = 0xff;
	P2 = P2 & 0x1f | 0xe0;
	P2 &= 0x1f;

	P0 = seg_wela[wela];
	P2 = P2 & 0x1f | 0xc0; 
	P2 &= 0x1f;
	
	P0 = seg_dula[dula];
	if(point)
		P0 &= 0x7f;
	P2 = P2 & 0x1f | 0xe0;
	P2 &= 0x1f;	
}
```



#### 5.整体大模板 （main.c部分）

![image-20250406163645452](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250406163645452.png)

说一下和之前不一样的地方：

1.定时器选择 频率 12MHz 定时长度 1毫秒  定时器0 模式 16位自动重新装载 时钟 12T   ET0和EA还是要加   AUXR可以不删了

![image-20250406165819340](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250406165819340.png)

2.中断函数中 不需要给定时器初值了，但是相比之前多了一个Led的索引和Led_Disp

3.主程序中多了一个System_Init()

```c
/*头文件声明区*/
#include <STC15F2K60S2.H>
#include "Seg.h"
#include "Init.h"
#include "Led.h"
#include "Key.h"

/*变量声明区*/
unsigned char Key_Val,Key_Up,Key_Down,Key_Old;//按键专用变量
unsigned char Key_Slow_Down;//按键减速专用变量
unsigned char Seg_Pos;//数码管扫描专用变量
unsigned char Seg_Buf[8] = {10,10,10,10,10,10,10,10};//数码管显示数据存放数组
unsigned char Seg_Point[8] = {0,0,0,0,0,0,0,0};//数码管小数点数据存放数组
unsigned char ucLed[8] = {0,0,0,0,0,0,0,0};//Led显示数据存放数组
unsigned int Seg_Slow_Down;//数码管减速专用变量
/*Key_Proc()*/
void Key_Proc()
{
	if(Key_Slow_Down) return;
	Key_Slow_Down = 1;//键盘减速程序
	
	Key_Val = Key_Read();//实时读取键码值
	Key_Down = Key_Val & (Key_Old ^ Key_Val);//捕捉按键下降沿
	Key_Up = ~Key_Val & (Key_Old ^ Key_Val);//捕捉按键上升沿
	Key_Old = Key_Val;//辅助扫描变量

}
/*Seg_Proc()*/
void Seg_Proc()
{
	if(Seg_Slow_Down) return;
	Seg_Slow_Down = 1;//数码管减速程序
	
	
}
/*Led_Proc()*/
void Led_Proc()
{

}
/*定时器*/
void Timer0Init(void)		//1毫秒@12.000MHz
{
	AUXR &= 0x7F;		//定时器时钟12T模式
	TMOD &= 0xF0;		//设置定时器模式
	TL0 = 0x18;		//设置定时初值
	TH0 = 0xFC;		//设置定时初值
	TF0 = 0;		//清除TF0标志
	TR0 = 1;		//定时器0开始计时
	
	ET0 = 1;		//定时器中断0打开
	EA = 1;			//总中断打开
}

/*中断函数*/
void Timer0Server() interrupt 1
{
	if(++Key_Slow_Down == 10) Key_Slow_Down = 0;//键盘减速专用
	if(++Seg_Slow_Down == 500) Key_Slow_Down = 0;//数码管减速专用
	if(++Seg_Pos == 8) Seg_Pos = 0;//数码管显示专用
	Seg_Disp(Seg_Pos,Seg_Buf[Seg_Pos]);
	Led_Disp(Seg_Pos,ucLed[Seg_Pos]);
}


/*主函数*/
void main()
{
	System_Init();
	Timer0Init();
	while(1)
	{
		Key_Proc();
		Seg_Proc();
		Led_Proc();
	}
}
```





#### 不同定时器/串口对应的中断函数 (interrupt ?)

在STC15系列手册里第六章吧，要学会看

![image-20250406171756544](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250406171756544.png)





### DS1302时钟模块

只需要管三个口

P17 串行时钟     P23 I/O口    P13 复位

![image-20250406205714207](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250406205714207.png)

1读0写   RD(read)读  W（write）写

![image-20250406210338010](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250406210338010.png)

------

两个步骤：

1.**定位到我们的地址** ： 看你要写什么  时分秒  比如选中秒 0x80（如图，最后一位给0，写入） 

2.**按格式写数据** 比如秒部分——10秒的地方写3就是30秒，秒字那里写4就代表4秒   即0x34（使用的是BCD码）

可能固定格式这里需要注意的是 小时部分

第一格给0——24进制，给1——12进制  

然后如果是24小时 不用在第三位控制上午或者下午，因为从时间上就能看出来   12小时需要控制第三位 0（AM）上午     1（PM）下午   

蓝桥杯多考的是24小时

举例：

选中月 0x88   九月份 0x09

------

BCD码讲解（BCD码江科大51单片机，10-2，30分钟的地方）

![image-20250406212228335](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250406212228335.png)



那时分秒等时钟地址在哪呢？

赛点资源包——竞赛板芯片资料——DS1302.pdf

![image-20250406213001419](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250406213001419.png)

80h ——指十六进制的0x80

 CH——给1暂停，给0运行 

关于CH默认给0：

看到图中秒的地址，因为秒的输入值最大时到59,59写成BCD码是01011001，不会把CH赋值为1，所以说是最高位的CH被忽略掉了（其实是CH根本不能等于1范围限制）

WP——写保护位  给0寄存器数据能写入  给1不能写入

 超过范围（比如我第一个写个61s）会忽略你的请求	

![image-20250406213649296](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250406213649296.png)





**后面所述代码部分不用背，赛点包会提供，仅做理解**

------

时序

必须满足一套规则，才能够正确使用

在上升沿才开始读入，即上升沿触发

**先写地址，再写数据**

![image-20250406214339581](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250406214339581.png)

地址：

```c
void Write_Ds1302(unsigned char temp)
{
 	unsigned char i;
    for(i = 0 ;i<8;i++)
    {
        SCK = 0;//拉低时钟线，准备数据
        SDA = temp&0x01;//取temp的最低位赋值给数据线
        temp>>=1;// temp右移一位，准备发送下一位
        SCK = 1;//时钟线拉高（DS1302在上升沿读取SDA）
    }
}
//屏蔽低7位数据，让temp值与上0x01就可以得到第一位的数据读入，而后再将temp右移与上0x01得到第二位，以此类推
```



补充：左移与右移

全部位置左移一位和全部位置右移一位

![image-20250407112513473](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250407112513473.png)

代码举例：

![image-20250407112719717](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250407112719717.png)

![image-20250407112732343](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250407112732343.png)

![image-20250407112745252](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250407112745252.png)

![image-20250407113932522](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250407113932522.png)

写数据：

```c
void Write_Ds1302_Byte(unsigned char address,dat)
{
    RST = 0; _nop_();//强制结束之前的任何未完成通信，避免干扰
    //插入一个空操作（No Operation），产生极短的延时（通常为1个CPU时钟周期）,确保RST引脚的电平稳定后再进行其他操作，避免时序冲突
    SCK = 0; _nop_();//确保时钟线SCK初始为低电平
    RST = 1; _nop_();//拉高RST（CE）引脚，启动通信
	Write_Ds1302(address);//发送目标寄存器地址
    Write_Ds1302(dat);//向目标寄存器写入数据
    RST = 0;//拉低RST（CE）引脚，结束通信
}
```



读字节数据：

```c
//DS1302 实时时钟芯片读取一个字节数据
unsigned char Read_Ds1302_Byte ( unsigned char address )
{
 	unsigned char i,temp=0x00;
    //初始化通信：先复位 RST 和 SCK，避免之前的信号干扰，再拉高 RST 启动 DS1302 的通信模式
 	RST=0;	_nop_();
 	SCK=0;	_nop_();
 	RST=1;	_nop_();
 	
    Write_Ds1302(address);//发送目标寄存器的读地址
    
 	for (i=0;i<8;i++) 	
 	{		
		SCK=0; //拉低时钟线，准备读取当前位
		temp>>=1; //右移temp，腾出最高位接收新数据	
 		if(SDA)
 		temp|=0x80;		
        //检测数据线 SDA 的电平，如果是高电平（1），则将 temp 的最高位置1
 		SCK=1;//拉高时钟线，DS1302 在上升沿后输出下一位数据
	} 
    //结束通信
 	RST=0;	_nop_();//拉低 RST 结束通信
 	SCK=0;	_nop_();//确保SCK回到低电平
	SCK=1;	_nop_();//额外时钟脉冲（部分芯片需要）
	SDA=0;	_nop_();//释放数据线（避免冲突）
	SDA=1;	_nop_();//恢复数据线高电平
	return (temp);	// 返回读取到的字节		
}
```

![image-20250407115909584](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250407115909584.png)



发现要写时分秒的时候，怎么用这个模块呢？

写好大模板——找到赛点资源包——找到底层驱动代码参考——ds1302.c复制到我们自己的Driver文件夹去

.h文件要自己写   那些预定义的头文件也要自己写了，reg52.h一定要写，出现了nop要写intrins.h，引脚可以去赛点资源包的硬件原理图查（搜索DS1302）

![image-20250407150317602](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250407150317602.png)

ds1302.h

![image-20250407150357049](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250407150357049.png)

ds1302.c

![image-20250407152008139](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250407152008139.png)



#### 要自己写的底层部分

然后因为我们自己要写时分秒，所以定义一个模块化函数（**自己写的，要背！**）

unsigned char* ucRtc用unsigned char ucRTC[3]也行，但是我用了指针，数组名字ucRtc就是它的地址，加个*代表指向它的地址

首先给WP保护位拉低，这样才能写入，地址是0x8E，数据是0x00

Write_Ds1302_Byte(0x8e,0x00)

![image-20250407135134408](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250407135134408.png)

小时怎么写？假设默认24小时制，要表示23时（BCD码为0x23）

我们把小时存放在数组第0位

Write_Ds1302_Byte(0x84,ucRtc[0])

![image-20250407135324604](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250407135324604.png)

分跟秒

![image-20250407135714886](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250407135714886.png)

Write_Ds1302_Byte(0x84,ucRtc[1])

Write_Ds1302_Byte(0x84,ucRtc[2])

![image-20250407135134408](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250407135134408.png)

写完再把写保护位WP打开

1000 0000 ——0x80

Write_Ds1302_Byte(0x8e,0x80)

其中时分秒的部分有规律可循，可写成for循环

```c
void Set_Rtc(unsigned char* ucRtc)
{
	unsigned char i;
	Write_Ds1302_Byte(0x8e,0x00);
	for(i=0;i<3;i++)
		Write_Ds1302_Byte(0x84-2*i,ucRtc[i]);
	Write_Ds1302_Byte(0x8e,0x80);
}
```



读DS1302:

读小时是0x85，读分钟是0x83，读秒钟是0x81

读就是把数据存入数组

![image-20250407140217818](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250407140217818.png)

```c
void Read_Rtc(unsigned char* ucRtc)
{
	unsigned char i;
	for(i=0;i<3;i++)
		ucRtc[i] = Read_Ds1302_Byte(0x85-2*i);
}
```

再次提醒，写完后在.h文件里面声明



#### 主函数的时钟部分如何写

1.声明头文件#include "ds1302.h"

2.声明时钟数据存放数组

unsigned char ucRtc[3] ={0x23,0x59,0x55};//时钟数据存放数组 默认23:59:55

(注意：注：在v5大模板上，ds1302的底层代码将十六进制转换成了十进制，则ucRtc数组数据以十进制存储，例“={23,59,55}”)

3.Set_Rtc只需要在上电的时候设置一下就行

```c
/*主函数*/
void main()
{
	System_Init();
	Timer0Init();
	Set_Rtc(ucRtc);//上电时设置时间
	while(1)
	{
		Key_Proc();
		Seg_Proc();
		Led_Proc();
	}
}
```

4.Read_Rtc读取时间的话是要显示的，那可以在Seg_Proc中开区域写

当然也要读取后要放到Seg_Buf[]中，由于是十六进制的BCD码，需要转换成十进制再存入Seg_Buf[]（我们13是 将13/10取十位，13%10取个位，那0x13就是 将13/16取十位，13%16取个位）

我们要显示xx-xx-xx  “-”横杠在共阳极数码管（给0是亮）的编码是

1011 1111 ，即0xbf，将这个加到seg_dula[]中，其他就好写了 

```C
/*Seg_Proc()*/
void Seg_Proc()
{
	if(Seg_Slow_Down) return;
	Seg_Slow_Down = 1;//数码管减速程序
	
	/*信息读取区域*/
	Read_Rtc(ucRtc);//实时读取时钟数据
	
	/*数据处理区域*/
	Seg_Buf[0] = ucRtc[0] / 16;
	Seg_Buf[1] = ucRtc[0] % 16;
	Seg_Buf[2] = 11;
	Seg_Buf[3] = ucRtc[1] / 16;
	Seg_Buf[4] = ucRtc[1] % 16;
	Seg_Buf[5] = 11;
	Seg_Buf[6] = ucRtc[2] / 16;
	Seg_Buf[7] = ucRtc[2] % 16;
}
```

如果时钟一下跳两三秒说明刷新间隔太长了，将Seg_Slow_Down调低一点就行

仿真图如何调取DS1302窗口

![image-20250407152302704](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250407152302704.png)



#### 拓展性问题

1.除时分秒外，日期那些怎么搞?

先在赛点资源包——竞赛板芯片资料找到DS1302——找到地址这一页

![image-20250407152751181](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250407152751181.png)

原理都是  写保护WP关闭——先写地址，再写数据——写保护WP打开

读数据看好地址，赋值给数组就行



### 蓝桥杯模块训练一：模拟电子钟

##### 1.补充DS1302模块

发现需要DS1302模块，我们再加上去，但基础的Init、Key、Seg、Led模块必须加



##### 2.定义界面变量

发现有六个界面，时钟显示、时钟设置、闹钟显示、闹钟设置、日期显示、日期设置。那我们可以把显示界面的放一起，设置界面的放一起 ，那后面有显示界面切换这种我们++就行，不用还要写好多个if

```c
unsigned char Seg_Disp_Mode;//数码管显示模式变量 0-时钟显示 1-闹钟显示 2-日期显示 3-时钟设置 4-闹钟设置 5-日期设置
```

##### 3.以BCD码形式存放时钟数据

```c
unsigned char ucRtc[3] = {0x23,0x59,0x55};//时钟数据存放数组 上电初始化时间 23:59:55
```

##### 4.上电初始化DS1302芯片

![image-20250408094028019](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250408094028019.png)

##### 5.实时读取DS1302数据并显示在数码管上

![image-20250408094340297](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250408094340297.png)

##### 6.在Seg_Proc数据处理区域

![image-20250408094910717](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250408094910717.png)

怎么优化呢？

可以找规律用for循环归纳起来

![image-20250408095137320](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250408095137320.png)



##### 7.闹钟查看界面

可以顺着逻辑来，接着写闹钟查看界面，先不写设置界面

有三个闹钟，这里该怎么定义闹钟数据变量是一个难点

1）

方法一：定义二维数组（建议以BCD码的形式定义）

```c
unsigned char Alarm_Dat[3][3] = 
{
	{0x00,0x00,0x00},
	{0x00,0x01,0x00},
	{0xbb,0xbb,0xbb}
};
```

虽然以BCD码的形式定义，后面修改数据是一个难点，但是避免了很多次的进制转换，是利大于弊的

0xbb是什么？——我们的“-”横杠对应段码数组里面的11，不管是时分秒都是两位，每一位都是11，每一位转成BCD码的形式定义是0x11，即b，所以对应时分秒的部分就是0xbb（每一位都是横杠，有两位，两个横杠，一个横杠是b，两个横杠是bb）



方法二：

```C
unsigned char ucAlarm[9] = {0x00,0x00,0x00,0x00,0x10,0x00,0xbb,0xbb,0xbb};//闹钟数据存放数组 三组闹钟 未启用0xbb表示
```

2）定义闹钟编号变量

```c
unsigned char Alarm_Dat_Index;//闹钟数组指针 用于表示闹钟编号
```

3）显示闹钟数据

方法一：

一样，用for循环总结规律

```c
case 1://闹钟显示
			for(i=0;i<3;i++)
			{
				Seg_Buf[3*i] = Alarm_Dat[Alarm_Dat_Index][i] / 16;
				Seg_Buf[3*i+1] = Alarm_Dat[Alarm_Dat_Index][i] % 16;
			}
			Seg_Buf[2] = Seg_Buf[5] = 11;		
break;
```





方法二：

总结规律：

显示屏时分秒的位置是  01  34    67     刚好是3×i和3×i+1

第一、二、三组闹钟分别是   012    345   678    刚好是i+3*Alarm_Dat_Index

```c
case 1://闹钟显示
			for(i=0;i<3;i++)
			{
				Seg_Buf[3*i] = ucAlarm[i+3*Alarm_Dat_Index] / 16;
				Seg_Buf[3*i+1] = ucAlarm[i+3*Alarm_Dat_Index] % 16;
			}	
		break;
```

##### 8.日期显示界面

1）补充日期相关底层

先在赛点资源包——竞赛板芯片资料找到DS1302——找到地址这一页

![image-20250407152751181](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250407152751181.png)

找到年月日，年：写0x8C，读0x8D  月：写0x88，读0x89

日：写0x8A 读0x8B

在ds1302.c中补充Set_Date

WP开——地址加数据——WP关

```c
void Set_Date(unsigned char* ucDate)
{
	Write_Ds1302_Byte(0x8e,0x00);
	Write_Ds1302_Byte(0x8c,ucDate[0]);
	Write_Ds1302_Byte(0x88,ucDate[1]);
	Write_Ds1302_Byte(0x86,ucDate[2]);
	Write_Ds1302_Byte(0x8e,0x80);	
}

```

同样，读数据函数也是，把读ds1302数据的值赋给数组，就是读数据函数

```c
void Read_Date(unsigned char* ucDate)
{
	ucDate[0] = Read_Ds1302_Byte(0x8d);
	ucDate[1] = Read_Ds1302_Byte(0x89);
	ucDate[2] = Read_Ds1302_Byte(0x87);
}
```

2) 定义日期数据函数

```c
unsigned char ucDate[3] = {0x22,0x12,0x12};//日期数据存放数组 上电初始化日期 22-12-12
```

3）上电初始化日期

![image-20250408110121410](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250408110121410.png)

4）实时读取日期数据

![image-20250408110229069](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250408110229069.png)

5）显示日期数据在数码管上

![image-20250408110311728](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250408110311728.png)



接下来就可以编写按键，看我们写的对不对了

##### 9.显示切换界面

![image-20250408161343415](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250408161343415.png)

非参数设置状态下,在三个显示模式下循环

```c
case 14://界面切换按键
			if(Seg_Disp_Mode < 3) //在非参数设置状态下使能
			{
				if(++Seg_Disp_Mode == 3) //在0-2之间循环切换
					Seg_Disp_Mode = 0;
			}
		break;
```



接下来就要考虑从某个界面的显示界面跳转设置界面的按钮了，所以写跳转前我们要把设置界面写了

![image-20250408162019618](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250408162019618.png)

##### 10.编写时钟设置界面

1) 定义时钟设置数组

方法1：

由于我们设置界面不能互切，只能进入显示界面——切设置界面，所以是相对互斥的，可以用一个数组表示三个设置界面

**但是我们闹钟是个二维数组，所以闹钟的设置数组肯定也得是二维，而时钟和日期数组都是一维数组，这里就被卡住了**

**所以要么写三个数组，分别表示时钟、闹钟、日期数组，要么我们优化一下**

![image-20250408162842733](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250408162842733.png)

优化路线见7.1，方法二  7.2 方法二

方法2：

改完后我们就能只定义一个设置数组，去简化变量繁多的问题了

闹钟有三个，数组需要到9，所以我们数组也定义9

```c
unsigned char Set_Dat[9];//设置数据存放数组 如果三个模式定义三个不同的设置数组会大量占用资源 又因为这三个模式在设置状态下并不会互相影响（互斥存在关系） 所以只需要定义一个设置数组 根据不同的界面将不同的数据赋值给这个数组
```

首先在Seg_Proc中，

由于时钟显示——时钟设置   日期显示——日期设置，我们的显示界面都会提前赋值，只有闹钟界面会用到九个数组元素，所以我们的设置界面可以合并为

![image-20250408205005658](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250408205005658.png)



然后回到Key_Proc，

在非参数设置状态下，我们加3直接到达对应的设置界面，到达顺便把指针复位一下

（0-时钟显示 1-闹钟显示 2-日期显示 3-时钟设置 4-闹钟设置 5-日期设置）

接着就是看我们到达了那个设置界面

开个switch，如果是时钟设置界面，那就for循环把时钟显示数组ucRtc[3]赋值给设置数组Set_Dat[9];如果是闹钟设置界面，那就for循环把时钟显示数组ucAlarm[9]赋值给设置数组Set_Dat[9]；如果是日期设置界面，那就for循环把日期显示数组ucDate[3]赋值给设置数组Set_Dat[9]

图中老师的做法是拷贝函数，memcpy(目标数组，数据数组，数据长度)，需要附带头文件#include <string.h>

![image-20250409113248763](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250409113248763.png)

这里我查的Deepseek说还是按照数组长度来写拷贝长度的好，不要都写9



这是简化，不会用的话不用![image-20250409113554441](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250409113554441.png)



##### 11.设置界面完善

1)定义计时变量、闪烁标志位

```c
unsigned int Timer_500Ms;//五百毫秒计时变量
bit Led_Star_Flag;//Led闪烁标志位

void Timer0Init() interrupt 1
{
	if(++Timer_500Ms == 500)
	{
		Timer_500Ms = 0;//计时值复位
		Seg_Star_Flag ^= 1;//标志位取反
	}
}
```

2) 闪烁判断位，看看是哪个部分闪烁

```c
unsigned char Input_Index;//输入位数变量 用于判断哪个单元格需要闪烁
```

![image-20250409142630594](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250409142630594.png)

如果不会总结也还是用if，if（Input_Index==0）对应小时，那就Seg_Buf[0] = 闪烁标志位 ？ Set_Dat[0+3*Alarm_Dat_Index]/16:10  和    Set_Dat[0]%16:10

Seg_Buf[1] = 闪烁标志位 ？ Set_Dat[1+3*Alarm_Dat_Index]/16:10  和    Set_Dat[1]%16:10

分钟和秒也同理   



##### 12.**数据输入** （小难点，可以多看看思路）

由于我们做数组时都是将小时、分钟、秒的十位和个位做成一个数组元素，所以输入时我们要定义标志位，看看现在输入到十位还是个位了

1）定义标志位

```c
bit Input_Flag;//输入标志位 用于判断输入十位还是个位
```

2）按键数据输入（由于我们数组是BCD码，但输入进来的数据是十进制，难点在这里）

假设我现在要输入十位，A是0x23， 输入了一个4  如何变成 0x43 ？

A&0x0f 保存后四位的数据先，现在变成0x03 那再或上 B <<4  ,就能够得到答案了

![image-20250409150035515](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250409150035515.png)

输入个位？  那就更简单了

A & 0xf0  | B



那就是如果Input_Flag = 0，输入十位 ；不是0的话，输入个位

输入完我们再把Input_Flag ^=1    这时候看Input_Flag是否是0，是0就让我们前面的单元格标志位加1，我们可以用这个单元格标志位来位移数组

![image-20250409151434420](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250409151434420.png)



##### 13.**数据保存**（小难点）

![image-20250409151702981](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250409151702981.png)

1）数据合理性判断

我们的数据都在Set_Dat里，判断这个数组就行了



1.取余10的目的是避免一些数据干扰，比如0xbb，不去取余10的话运行下来就是 11×10 + 11  =121

2.*Dat就是数组Dat的指针，比如传进来的是Dat[0],指向的就是Dat[0] ;Dat++就是指针指向下一个地址，下一次指向的是Dat[1]

（如果是变量要传进来，需要加&  比如&a；）

我的改进代码如下：

```c
/* 数据判断函数优化版 */
unsigned char Dat_Judgment(unsigned char* Dat, unsigned char mode) {
    unsigned char i;
    unsigned int Dat_Array[3];
    
    // BCD转十进制（保留原处理方式）
    for(i=0; i<3; i++) {
        unsigned char high = (*Dat >> 4) % 10;  // 更清晰的高位提取
        unsigned char low = (*Dat & 0x0F) % 10; // 清晰的低位提取
        Dat_Array[i] = high * 10 + low;
        Dat++;
    }

    // 根据模式分流校验
    return (mode == 2) ? Date_Check(Dat_Array) : Time_Check(Dat_Array);
}

/* 日期校验子函数 */
static unsigned char Date_Check(unsigned int* date) {
    // 年处理
    unsigned int year = 2000 + date[0]; // 假设date[0]是00-99表示2000-2099
    
    // 月份校验
    if(date[1] < 1 || date[1] > 12) return 0;
    
    // 日期基础校验
    if(date[2] < 1 || date[2] > 31) return 0;

    // 各月份天数校验
    const unsigned char days_per_month[] = {31,28,31,30,31,30,31,31,30,31,30,31};
    unsigned char max_days = days_per_month[date[1]-1];
    
    // 闰年二月处理（修复条件）
    if(date[1] == 2) {
        int is_leap = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
        max_days += is_leap; // 闰年2月加1天
    }
    
    return (date[2] <= max_days) ? 1 : 0;
}

/* 时间校验子函数 */
static unsigned char Time_Check(unsigned int* time) {
    // 小时校验
    if(time[0] > 23) return 0;
    
    // 分秒校验
    return (time[1] <= 59 && time[2] <= 59) ? 1 : 0;
}
```



然后S15在参数界面时，数据合理——返回显示界面   数据不合理——重新输入

所以我们S15就可以完善一下

首先先看标志位，满三次说明输入完了，让它进数据合理性判断；没满直接清零，指示单元格标志位和十位个位标志位清零

数据不合理也清零，标志位也复位

合理:

看看是哪个模式，时钟模式就写入数据Set_Dat  （Set_Rtc(Set_Dat)）

闹钟模式就用for循环或者拷贝函数将Set_Dat赋值给ucAlarm

日期模式也是写入数据Set_Dat

然后回到对应模式的显示模式

整合S15：

```c
unsigned char* Set_Flag[3] = {ucRtc,ucAlarm,ucDate};//指针数组 简化数据赋值专用
case 15://参数设置按键
			if(Seg_Disp_Mode < 3) //在非参数设置状态
			{
				Seg_Disp_Mode += 3;//切换到对应的设置界面内
				Alarm_Dat_Index = 0;//闹钟指针复位
//				memcpy(Set_Dat,Set_Flag[Seg_Disp_Mode-3],9);//Set_Flag为指针数组 Set_Flag[0] 代表 ucRtc 数组的地址 以此类推
				switch(Seg_Disp_Mode)
				{
					case 3://切换到时钟设置界面
						memcpy(Set_Dat,ucRtc,9);
					break;
					case 4://切换到闹钟设置界面
						memcpy(Set_Dat,ucAlarm,9);
					break;	
					case 5://切换到日期设置界面
						memcpy(Set_Dat,ucDate,9);
					break;						
				}
			}
			else//在参数设置状态下
			{
				if(Input_Index == 3)//只有输入完三次数据后才能使能保存按键
				{
					if(Dat_Judgment(&Set_Dat[0],Seg_Disp_Mode-3) && Dat_Judgment(&Set_Dat[3],Seg_Disp_Mode-3) && Dat_Judgment(&Set_Dat[6],Seg_Disp_Mode-3))
					{
						switch(Seg_Disp_Mode)
						{
							case 3:
								Set_Rtc(Set_Dat);//设置新的时钟数据
							break;
							case 4:
								memcpy(ucAlarm,Set_Dat,9);//保存闹钟数据
							break;
							case 5:
								Set_Date(Set_Dat);//设置新的日期数据
							break;
						}
						Seg_Disp_Mode -= 3;//跳转回数据显示界面
					}
					else
					{
						memcpy(Set_Dat,Set_Flag[Seg_Disp_Mode-3],9);//清除输入数据
						Input_Index = Input_Flag = 0;//输入系列数据复位
					}

				}
			}
		break;
```

------

这里的指针数组用的挺好的，多学习几遍

------



##### 14.闹钟删除

![image-20250409175954578](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250409175954578.png)

闹钟设置界面下有效

内部用for循环，与指示闹钟编号的索引配合  01  34  67号位变成"-",那也就是  3*Alarm_Dat_Index + i，然后顺手把输入的两个标志位复位一下，因为可能删除完闹钟就要输入了



```c
case 19://闹钟删除按键
			if(Seg_Disp_Mode == 4)//处于闹钟设置界面
			{
				for(i=0;i<3;i++)
					Set_Dat[3*Alarm_Dat_Index + i] = 0xbb;//清空数据
				Input_Index = 0;
				Input_Flag = 0;
			}
		break;
```



##### 15.闹钟切换

有指示闹钟编号的索引,那很顺手了  0   1  2  ，加到3后清0

![image-20250409180723892](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250409180723892.png)

![image-20250409180734892](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250409180734892.png)

```c
case 17://闹钟切换按键
			if(Seg_Disp_Mode == 1 || Seg_Disp_Mode == 4) // 处于闹钟显示界面
			{
				if(++Alarm_Dat_Index == 3) //在0-2之间循环切换
					Alarm_Dat_Index = 0;				
			}
		break;
```



##### 16.设置退出界面

![image-20250409180828661](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250409180828661.png)

![image-20250409181029281](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250409181029281.png)

0-时钟显示 1-闹钟显示 2-日期显示 3-时钟设置 4-闹钟设置 5-日期设置

设置界面回当前参数的显示界面 -3  就行了，当然，顺手把标志位复位了

```c
case 16://设置退出按键
			 if(Seg_Disp_Mode >= 3)
			 {
				 Seg_Disp_Mode -=3;
				 Input_Index = 0;
				 Input_Flag = 0;
			 }
		break;
```



##### 17.闹钟功能按键

![image-20250409181457916](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250409181457916.png)

![image-20250409181505845](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250409181505845.png)

没定义过，那我们定义一个开启标志位就好了

1) 定义标志位

```c
bit Beep_Enable_Flag = 1;//闹钟功能开启标志位
```

2）编写按键代码

```c
case 18://闹钟功能按键
			if(Seg_Disp_Mode < 3)//处于非参数设置界面
				Beep_Enable_Flag ^= 1;
```



##### 18.Led显示

1）L1

![image-20250409193058563](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250409193058563.png)

使能什么意思？ 就是当时钟的时间到达闹钟的时间的时候，闹钟使能

1.定义标志位

```c
bit Beep_Flag;//闹钟使能标志位
```

2.在Led_Proc中编写使能

笨方法我们可以if到底

```c
	if(ucAlarm[0] == ucRtc[0] && ucAlarm[1] == ucRtc[1] && ucAlarm[2] == ucRtc[2])
		Beep_Flag = 1;
	if(ucAlarm[3] == ucRtc[0] && ucAlarm[4] == ucRtc[1] && ucAlarm[5] == ucRtc[2])
		Beep_Flag = 1;
	if(ucAlarm[6] == ucRtc[0] && ucAlarm[7] == ucRtc[1] && ucAlarm[8] == ucRtc[2])
		Beep_Flag = 1;
```

也可以改进一下

```c
for(i=0;i<3;i++)//使用循环简化代码 当检测到一个闹钟使能时 直接退出循环 减少运行资源占用
	{
		if(ucAlarm[0+i*3] == ucRtc[0] && ucAlarm[1+i*3] == ucRtc[1] && ucAlarm[2+i*3] == ucRtc[2])
		{
			Beep_Flag = 1;
			Beep_Index = i;//记录闹钟编号
			break;	//只要有满足条件的闹钟，跳出for循环
		}
```

3.持续5秒

43 —— 48   59——04    发现我们只要关注个位就行，十位不管是什么都不影响

那依旧在我们的Led_Proc中，只要某只闹钟秒数的个位 +5  = 时钟秒数的个位  就关闭闹钟

```c
if(Beep_Flag == 1)//闹钟处于使能状态
	{
		if((ucRtc[2] % 16) ==  ((ucAlarm[2+Beep_Index*3] % 16) + 5) % 10)//记录五秒
			Beep_Flag = 0;//关闭闹钟
	}
```

4.闹钟功能启动时，0.2秒闪烁

```c
bit Led_Star_Flag;//Led闪烁标志位
/*中断计时的步骤我省了，写好多遍了*/
ucLed[0] = Led_Star_Flag?(Beep_Flag&Beep_Enable_Flag):0;
```

是我可能要if了，不过也能写出来

```c
if(Beep_Enable_Flag == 1  && Beep_Flag == 1)

	ucLed[0] = Led_Star_Flag ? 1 : 0;
```



2) 点亮L2-L4  

这种互斥点亮来表明状态的，在蓝桥杯中十分常见

![image-20250409200829759](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250409200829759.png)

依旧可以if到底  或者switch

```C
if(Seg_Disp_Mode == 1 || Seg_Disp_Mode == 4)
{
  if(Alarm_Dat_Index == 0)  //索引 0  1  2
      ucLed[1] = 1;
    ...
  switch(Alarm_Dat_Index)
      case 0 :
    	ucLed[1] = 1;
}
```

老师用的for循环，十分巧妙   只有两个条件都满足，才为1，灯才亮   但是我的好理解一点

```c
unsigned char i;//For循环专用变量
	for(i=1;i<4;i++)//常用互斥点亮思路 利用位运算符 条件满足时默认返回1
		ucLed[i] = (i == Alarm_Dat_Index + 1) * (Seg_Disp_Mode == 1 || Seg_Disp_Mode == 4);//处于时钟界面时 点亮相应的Led指示灯
```



3）点亮L8

![image-20250409202712647](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250409202712647.png)

注意它只说了闹钟被删除时无效，闹钟被关闭了是有效的，我第一次就曲解题意了

我的建议是在前面S19闹钟删除按键处补充一个标志位，闹钟被删除标志位置1，

然后在S4-S13键盘输入区域，当Input_Index == 3（只有输入完三次数据后才是3），让标志位置0

然后ucLed[7] = 标志位   ，这样就行了

老师做法：看时钟值，时钟最大为0x23。只有一种可能也就是0xbb会大过0x24，得到1，这样取反就是0

```c
ucLed[7] = !(ucAlarm[3*Alarm_Dat_Index] / 0x24) * (Seg_Disp_Mode == 1 || Seg_Disp_Mode == 4);//若时钟值比23大 则表示未启用
```

------

大体逻辑都是从数码管入手，缺什么补什么，最后写Led模块

------





### DS18B20模块

#### 理论知识

1.单总线接口，只需要一个引脚来通信（1_wire）

2.每个芯片内都有一个id（序列号），用于识别芯片

3.温度测量范围是-55°c — 125°c  （一般常测量范围就是0°c—85°c）

下面是封装图、引脚跟芯片关系、引脚作用

![image-20250409205606418](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250409205606418.png)

第二种方形的腿很多，但是能用的就是DQ、GND、VDD

接到P14引脚上



下图中前面的部件不需要管，暂存器我们需要了解

![image-20250409205850487](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250409205850487.png)



图中温度低位（LSB）和温度高位（MSB）两者加在一起是85度，所以上电后默认显示85°c

byte2、byte3储存我们最高、最低温度数据，从EEPROM读取出来的

![image-20250409210523176](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250409210523176.png)



时间问题，后面原理部分写的不会很详细，谅解...

bit0 -bit3 小数位

bit4-bit10 整数位                    共16位

bit11-bit15 符号位

![image-20250409210847768](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250409210847768.png)

简单了解，比赛会给，不用自己推



温度报警（byte2、byte3部分，考的少）

![image-20250409211037430](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250409211037430.png)



接着是最后一部分，配置寄存器（未考），用来设定精度的

![image-20250409211136521](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250409211136521.png)

要配置的精度越高，所需时间越长





![image-20250409212012237](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250409212012237.png)



#### 初始化DS18B20

主机发送信号给DS18B20，主机接收到DS18B20返回的信号，初始化就结束了



拉低总线，然后释放总线，在这时间内读取电平变化，如果是低电平，说明初始化完成了

拉低60-240us后，自动释放总线

![image-20250409212738663](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250409212738663.png)



#### 要自己补充的代码

赛点资源包中包含延时函数，读，写函数以及初始化函数

```c
float rd_temperture()
{
    unsigned char low,high;
    init_ds18b20();
    Write_ds18B20(0xcc); //跳过ROM命令
    Write_ds18B20(0x44); //写启动转换命令
    init_ds18b20();
    Write_ds18B20(0xcc); 
    Write_ds18B20(0xbe); 
    
    low = Read_DS18B20();
    high = Read_DS18B20();
    return ((high<<8) | low) / 16.0;
}
```

main.c中

```C
float Temperture;//温度储存变量
void Seg_Proc()
{
	if(Seg_Slow_Down) return;
    Seg_Slow_Down = 1;
    
    /*信息获取区域*/
    Temperture = rd_temperture();//实时读取温度数据
    /*数据显示区域*/
    
}
```



### DS18B20模块训练

时间问题，只讲解难点或者不太好写的地方

1.添加温度模块

跟上面一样，发现有温度部分后加入温度模块

2.温度值如何显示？

![image-20250411164055013](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250411164055013.png)

由于Temperture是浮点数，我们取第一位应该是先强制取整（unsigned char 或者unsigned int都行）然后/10%10

取第二位就%10  第三位就要先乘10变成三位数再%10

![image-20250411164620310](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250411164620310.png)

3.上电后我们的温度模块会有一个很长的时间显示默认温度85度，怎么改？

**进行延时750ms**

在stc—isp中找到软件延时计算器，延时750ms，生成代码，删掉nop（）；  写完此函数后，添加到主函数中

![image-20250411164937521](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250411164937521.png)

![image-20250411165052993](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250411165052993.png)



4.参数设置界面

![image-20250411170113201](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250411170113201.png)

看到要调整TMAX和TMIN这种就要定义**两个数组**，一个数组是用来显示的，一个数组是实际控制的

![image-20250411180741530](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250411180741530.png)

实际控制数组就用来保存你设置好的TMAX和TMIN

这里就是切换到Seg_Disp_Mode =0的时候需要看一下，如果上限大于下限就将P_Dat保存到P_Ctrol，否则不存

然后进入到参数设置界面Seg_Disp_Mode =1的时候再把P_Ctrol赋值给P_Dat，这样就实现数据更新了

![image-20250411175414511](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250411175414511.png)



5.有些位数一直熄灭的不用管，但是比如Seg_Buf[3]在第二个界面用了，Seg_Buf[5]有小数点，这种在界面切换的时候就要注意一下

![image-20250411170639691](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250411170639691.png)



6.长按0.5s快速加减

![image-20250411175723610](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250411175723610.png)

![image-20250411175653841](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250411175653841.png)

首先一个计时0.5秒的变量  一个开始计时的标志位

在中断中，如果计时标志位被拉高，我们就开始计时，但是注意限制一下，以免超过上限

在按键函数中，如果按下相对应的按键，就拉高标志位

如果按键小于500ms且Key_Up了（抬起动作）， 那我们清零计时变量和标志位就行，当然还是要加边界判断

如果大于500ms 且Key_Old(一直按着)，那我们就一直加加，外加一个边界判断；如果中途Key_Up了（抬起动作），清零计时变量和标志位

```c
unsigned int Key_Time;//纪录按键时间变量
bit Key_Flag;//按键使能标志位

void Timer0Server() interrupt 1
{
    if(Key_Flag == 1)
    {
     if(++Key_Time == 601) //防止有人一直按着超过int上限了
     	Key_Time = 600;
    }
}

void Key_Proc()
{
	if(Seg_Disp_Mode == 1)
    {
        if(Key_Down == 14)
            Key_Flag = 1;//拉高标志位，开始计时
	}
    if(Key_Time < 500) //按键在500毫秒之内
    {
		if(Key_Up == 14) //短按
        {
            Key_Flag = Key_Time = 0;
            if(++P_Dat[P_Dat_Index] == 71)
                P_Dat[P_Dat_Index] = 10;
		}
    }
    else //按下按键超过500ms
    {
		if(Key_Old == 14)
        {
            if(++P_Dat[P_Dat_Index] == 71)
                P_Dat[P_Dat_Index] = 10;
        }
        if(Key_Up == 14)
            Key_Flag = Key_Time = 0;
    }
}
```



7.Led模块

![image-20250411203043184](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250411203043184.png)

看到需要识别错误的参数，那我们需要定义一个标志位，

```c
bit error_flag = 0; // 参数错误标志位
```

在Key_Proc中，

```c
case 12://界面切换
    if(++Seg_Disp_Mode == 2) Seg_Disp_Mode = 0;
    if(Seg_Disp_Mode == 0) { // 切换到温度界面
        P_Dat_Index = 0;
        // 参数合法性检查
        if(P_Dat[0] > P_Dat[1]) {
            P_Ctrol[0] = P_Dat[0];
            P_Ctrol[1] = P_Dat[1];
            error_flag = 0; // 参数合法
        } else {
            error_flag = 1; // 触发错误标志
        }
    }
    // 其他代码不变...
```

在Led_Proc中

```c
void Led_Proc() {
    // 全部LED默认熄灭
    ucLed[0] = ucLed[1] = ucLed[2] = ucLed[3] = 0;

    // 错误状态优先判断
    if(error_flag) {
        ucLed[3] = 1; // L4点亮
        return;
    }

    // 温度状态判断
    if(Temperature > P_Ctrol[0]) {        // 超上限
        ucLed[0] = 1;                    // L1亮
    } else if(Temperature < P_Ctrol[1]) { // 低下限
        ucLed[2] = 1;                    // L3亮
    } else {                              // 正常范围
        ucLed[1] = 1;                    // L2亮
    }
}
```



8.Led亮度等级

![image-20250412102013314](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412102013314.png)

![image-20250412101926714](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412101926714.png)

定义Level显示等级，Pwm实际控制

首先在中断中写入亮度控制,内部需要定义一个变量去设置亮度等级

```c
void Timer0Server() interrupt 1
{
	// PWM亮度控制（12级可调）
    if(++Led_Pwm >= 12) Led_Pwm = 0;
    
     // 根据亮度等级设置有效电平宽度
    unsigned char Level_Set = 0;
    switch(Level) 
    {
        case 1: Level_Set = 4; break;  // 33%亮度（12分频中亮4）
        case 2: Level_Set = 8; break;  // 66%亮度
        case 3: Level_Set = 12; break; // 100%亮度
    }
    
     // 更新显示
    if(Led_Pwm < Level_Set) {
        Led_Disp(Seg_Pos, ucLed[Seg_Pos]);
    } else {
        Led_Disp(Seg_Pos, 0);
    }
}
```

然后中断外部根据题意补齐就行

```c
void Led_Proc() {
    // 清除所有LED状态
    memset(ucLed, 0, sizeof(ucLed));//全部赋0也行

    // 错误状态优先
    if(error_flag) {
        ucLed[3] = 1; // L4全亮
        return;
    }

    // 设置亮度等级
    if(Temperature > P_Ctrol[0]) {        // 超温
        Level = 1;
        ucLed[0] = 1;                    // L1
    } 
    else if(Temperature < P_Ctrol[1]) { // 低温
        Level = 3;
        ucLed[2] = 1;                    // L3
    } 
    else {                              // 正常
        Level = 2;
        ucLed[1] = 1;                    // L2
    }
}
```



### PCF8591数模转换模块

#### 要自己补充的代码

读

通过 I²C 总线（一种电子设备间的“对话协议”），从一个模数转换芯片（比如 PCF8591）的指定通道读取模拟信号转换后的数字值

```c
unsigned char Ad_Read(unsigned char addr)
{
	unsigned char temp;
	IIC_Start(); //向总线发信号
	IIC_SendByte(0x90); //设备地址 + 写模式（告诉芯片准备接收指令）
	IIC_WaitAck(); //芯片回应确认信号（拉低总线电平）
    
	IIC_SendByte(addr); //告诉芯片要读哪个通道
	IIC_WaitAck();//芯片回应确认信号（拉低总线电平）
    
	IIC_Start();
	IIC_SendByte(0x91);
	IIC_WaitAck();	
    
	temp = IIC_RecByte();//temp存储读到的数据
	IIC_SendAck(1);//发1非应答信号终止传输
	IIC_Stop();//释放总线，结束通信
    
	return temp;
}
```

写

```c
void Da_Write(unsigned char dat)
{
	IIC_Start();
	IIC_SendByte(0x90);
	IIC_WaitAck();	
	IIC_SendByte(0x41);
	IIC_WaitAck();		
	IIC_SendByte(dat);	
	IIC_WaitAck();
	IIC_Stop();
}
```

记得写完在.h里声明一下

怎么用？

在我们信息处理函数Seg_Proc中

下图是读取了0x41（光敏电阻）的数字量

![image-20250412124425010](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412124425010.png)

比如说读取了0x43（滑动变阻器）,就是0~5v的电压转化成0-255的一个数字量



那我要读两个呢？

此时需要注意  **你此次读取的值是上一次转换的结果**

```C
dat = Ad_Read(0x41);
dat2 = Ad_Read(0x43);
```

这里的dat实际上读取的是0x43，dat2读取的是0x41



所以我们就人为的把它们两个变量调换一下，相当于在实际读取中将对应的值赋值到对应变量上  这样dat2读取的是0x43，dat读取的是0x41了

![image-20250412132827025](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412132827025.png)



DA是往里面写 还是在Seg_Proc中    0-5V被分成了0-255的数字，要多少网往上面填就是

![image-20250412133023873](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412133023873.png)



在蓝桥杯实际板子上就是用万用表测J3的19和20引脚



### 补充继电器和蜂鸣器

跟我们之前写的Led.c一样

继电器0x10  蜂鸣器0x40

1.temp那的飘号改一下

2.0x01改成0x10或0x40

3.无论继电器还是蜂鸣器都是把0x80改成0xa0

```c
#include <Led.h>

void Led_Disp(unsigned char addr,enable)
{
	static unsigned char temp = 0x00;
	static unsigned char temp_old = 0xff;
	if(enable)
		temp |= 0x01 << addr;
	else
		temp &= ~(0x01 << addr);
	if(temp != temp_old)
	{
		P0 = ~temp;
		P2 = P2 & 0x1f | 0x80;
		P2 &= 0x1f;
		temp_old = temp;
	}
}

void Beep(unsigned char flag)
{
	static unsigned char temp = 0x00;
	static unsigned char temp_old = 0xff;
	if(flag)
		temp |= 0x40;
	else
		temp &= ~0x40;
	if(temp != temp_old)
	{
		P0 = temp;
		P2 = P2 & 0x1f | 0xa0;
		P2 &= 0x1f;
		temp_old = temp;		
	}
}

void Relay(unsigned char flag)
{
	static unsigned char temp = 0x00;
	static unsigned char temp_old = 0xff;
	if(flag)
		temp |= 0x10;
	else
		temp &= ~0x10;
	if(temp != temp_old)
	{
		P0 = temp;
		P2 = P2 & 0x1f | 0xa0;
		P2 &= 0x1f;
		temp_old = temp;		
	}	
}
```



#### PCF8591模块训练

最常考的这个模块的方法就是   你通过AD读到一个0-255的数字量，怎么转换成0-5v电压值？ **就是把这个读到的数字量Dat/51.0，就是第一个界面对应的电压值**

![image-20250412134611189](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412134611189.png)



1.RB2 指滑动变阻器，就是0x43 

![image-20250412170404592](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412170404592.png)

那我们就创建一个浮点数电压变量，Ad_Read()读出数字值，除51.0得到电压

整数部分我们强制转换可以得到

小数部分我们可以先乘一百，然后再取出十位和个位就是小数了（最好都用unsigned int型强制类型转换，因为unsigned char范围只到0-255，电压值3以上乘100之后就超过255了）

![image-20250412171141798](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412171141798.png)





2.电压输出界面

一样的，我们创建一个电压输出变量Voltage_Output就行

其余照常

![image-20250412171413551](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412171413551.png)

![image-20250412171524672](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412171524672.png)







3.输出模式切换

![image-20250412173317613](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412173317613.png)

![image-20250412173341802](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412173341802.png)

首先有输出模式切换，那就需要一个变量调控

```c
bit Output_Mode;//电压输出模式变量 0-固定2V 1-随读取值变化
```

换模式（Key_Proc中）

```c
case 5://输出模式切换按键
			Output_Mode ^= 1;
		break;
```

写逻辑（Seg_Proc中）

![image-20250412173750842](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412173750842.png)

（上面写逻辑也可以用三目运算符）

```c
Voltage_Output = Output_Mode?Voltage:2;
```

这里我们只是按照题意写了这个DAC输出的标志，实际上我们DAC输出是放在LED函数里面

![image-20250412180009058](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412180009058.png)





4.

![image-20250412174109146](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412174109146.png)

```c
bit Seg_Enable_Flag = 1;//数码管使能标志位 0-不使能 1-使能
```

按键部分好写

```c
case 7://数码管显示功能控制按键
			Seg_Enable_Flag ^= 1;
		break;
```

实现部分有两种思路

1）直接在Seg_Proc里面使用if判断：为0就全灭，当然不要忘记关闭小数点

```c
	if(Seg_Enable_Flag == 0) //数码管不使能
	{
		Seg_Point[5] = 0;//关闭小数点使能
		for(i=0;i<8;i++)//熄灭所有数码管
			Seg_Buf[i] = 10;
	}
```

2）直接在中断中赋值

![image-20250412174531913](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412174531913.png)





5.Led模块

1）互斥点亮

![image-20250412180116737](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412180116737.png)

可以if判断写，但我们常用做法是for循环

在Led_Proc中

```C
unsigned char i;
for(i = 0;i<2;i++)//根据有几个灯我们动态调整i的范围
{
    ucLed[i] = (i == Seg_Disp_Mode)
}

```

![image-20250412194104554](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412194104554.png)

![image-20250412194034660](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412194034660.png)



![image-20250412194140797](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412194140797.png)

```c
ucLed[3] = Output_Mode;
```

### EEPROM（AT24C02）模块

一页最多只能写八个字节

![image-20250412200020550](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412200020550.png)

写函数

![image-20250412195501759](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412195501759.png)

读函数

![image-20250412195735024](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412195735024.png)



蓝桥杯考掉电不丢失，比如说给你一个上下限30和60，你改成20和70，然后掉电不丢失

写  EEPROM_Write(要写入的数组，地址（一般从第0位开始），写入几位)  如果写入的是变量，变量前加个取地址符即可            e.g.EEPROM_Write(dat,0,2)      EEPROM_Write(&a,0,1)

读 EEPROM_Read(dat,0,2)  EEPROM_Write(&a,0,1) 写在main函数中

如果有显示乱码的话那个读的操作就先不要写了先直接下载进去，然后将它存入eeprom，这样显示的就是正确的或者是写一个判断函数判断里面的旧的数据和新的一不一样，不一样的话先把新的写进去

unsigned int 需要把高位和低位拆开去写   b = a&0x0f取后四位这种或者用左移右移都行

### 超声波发射模块

![image-20250412204250850](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412204250850.png)

右边接收端，左边发射端

发射端TX = P1^0   接收端RX=P1^1

![image-20250412205502749](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412205502749.png)

![image-20250412205519554](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412205519554.png)

```c
#include <ultrasonic.h>
#include <intrins.h>

sbit Tx = P1^0;
sbit Rx = P1^1;

void Delay12us()		//@12.000MHz
{
	unsigned char i;

	_nop_();
	_nop_();
	i = 38;
	while (--i);
}


void Wave_Init()
{
	unsigned char i;
	for(i=0;i<8;i++)
	{
		Tx = 1;
		Delay12us();
		Tx = 0;
		Delay12us();
	}
}

unsigned int Ut_Wave_Data() //超声波距离读取函数
{
    unsigned int time;//时间储存变量
    CMOD =  0x00;//配置PCA工作模式
    CH = CL = 0;//复位计数值 等待超声波信号发出
    Wave_Init();//发送超声波信号
    CR = 1;//开始计时
    while((Rx == 1) && (CF == 0));//等待接受返回信号或者定时器溢出
    CR = 0;//停止计时
    if(CF == 0) //定时器没有溢出
    {
        time = CH << 8 | CL;//读取当前时间
        return (time * 0.017);//返回距离值
    }
    else
    {
        CF = 0;//清除溢出标志位
        return 0;
    }
}

```

怎么使用？

![image-20250412212104060](C:\Users\28293\AppData\Roaming\Typora\typora-user-images\image-20250412212104060.png)